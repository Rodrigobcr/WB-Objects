<?xml version="1.0" encoding="utf-8"?>
<nugget name="ABAP_WB_OBJECTS_V1_0">
 <CLAS CLSNAME="ZCX_WB_REPORT_WITHOUT_CLASS" VERSION="1" LANGU="E" DESCRIPT="Report/Include without classes" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_REPORT_WITHOUT_CLASS" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_REPORT_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Report/Include doesn&apos;t exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_REPORT_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="WB Objects generic exception" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="CX_STATIC_CHECK">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_WB_OBJECTS" REFCLSNAME="CX_STATIC_CHECK" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_IS_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Objects is not a class but an interface" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_IS_INTERFACE" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_CLASS_IS_MODEL_ONLY" VERSION="1" LANGU="E" DESCRIPT="Class is model only" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_CLASS_IS_MODEL_ONLY" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCX_CLASS_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Class do not exist" CATEGORY="40" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <inheritance CLSNAME="ZCX_CLASS_DONT_EXIST" REFCLSNAME="ZCX_WB_OBJECTS" VERSION="1" STATE="1"/>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SCANNER_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="Copy of include LS_ABAP_OBJECTS_SCANTOP" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCOPE_REC_TYPE" VERSION="1" LANGU="E" DESCRIPT="SCOPE_REC_TYPE" EXPOSURE="0" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="26 " TYPESRC_LENG="215 " TYPESRC="BEGIN OF scope_rec_type,
        clsname      TYPE c LENGTH 30,
        superclsname TYPE c LENGTH 30,
        is_interface TYPE c LENGTH  1,
        exposure     TYPE n LENGTH  1,
      END OF scope_rec_type
"/>
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCOPE_STA_TYPE" VERSION="1" LANGU="E" DESCRIPT="SCOPE_STA_TYPE" EXPOSURE="0" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="11 " SRCCOLUMN1="4 " SRCROW2="11 " SRCCOLUMN2="83 " TYPESRC_LENG="82 " TYPESRC="scope_sta_type TYPE STANDARD TABLE OF scope_rec_type WITH NON-UNIQUE KEY clsname
"/>
  <types CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="ME_PRIV_TYPE" VERSION="1" LANGU="E" DESCRIPT="ME_PRIV_TYPE" EXPOSURE="0" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="13 " SRCCOLUMN1="4 " SRCROW2="37 " SRCCOLUMN2="24 " TYPESRC_LENG="889 " TYPESRC="BEGIN OF me_priv_type,
*       tables for SCAN
        state_tab TYPE saboo_statt,
        token_tab TYPE saboo_tokstx,
        sourc_tab TYPE saboo_sourt,
*       global state
        clsname      TYPE c LENGTH 30,
        superclsname TYPE c LENGTH 30,
        is_interface TYPE c LENGTH  1,
        cmpname      TYPE c LENGTH  61,
        version      TYPE n LENGTH  1,
        langu        TYPE c LENGTH  1,
        exposure     TYPE n LENGTH  1,
        state        TYPE n LENGTH  1,
        mtdtype      TYPE n LENGTH  1,
*       nested scope stack &amp; counter
        nested_sc TYPE i,
        scope_sta TYPE scope_sta_type,
*       nested BEGIN ... END type declaration
        inside_begin_end TYPE i,
        begin_end_col    TYPE i,
        begin_end_row    TYPE i,
*       counter for editor order
        editor_order TYPE i,
      END OF me_priv_type
"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CONST" VERSION="1" LANGU="E" DESCRIPT="CONST" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="2" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="27 " SRCCOLUMN2="19 " TYPESRC_LENG="850 " TYPESRC="BEGIN OF const,
          max_line_size TYPE i VALUE 255,
          BEGIN OF aunit_duration,
            short  TYPE vseoclass-duration_type VALUE 12,
            medium TYPE vseoclass-duration_type VALUE 24,
            long   TYPE vseoclass-duration_type VALUE 36,
          END OF aunit_duration,
          BEGIN OF aunit_risk,
            harmless  TYPE vseoclass-risk_level VALUE 11,
            dangerous TYPE vseoclass-risk_level VALUE 22,
            critical  TYPE vseoclass-risk_level VALUE 33,
          END OF aunit_risk,
          BEGIN OF exposure,
            public    TYPE vseoclass-exposure VALUE 2,
            protected TYPE vseoclass-exposure VALUE 1,
            package   TYPE vseoclass-exposure VALUE 3,
            private   TYPE vseoclass-exposure VALUE 0,
          END OF exposure,
        END OF const
"/>
  <attribute CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="ME_PRIV" VERSION="1" LANGU="E" DESCRIPT="ME_PRIV" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="5" TYPE="ME_PRIV_TYPE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" VERSION="1" LANGU="E" DESCRIPT="CREATE" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="RESOLVE_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="RESOLVE_INCLUDES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="SCANNER" VERSION="1" LANGU="E" DESCRIPT="SCANNER" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_WB_SCANNER_OBJECTS"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="ERROR_SOURCE" VERSION="1" LANGU="E" DESCRIPT="ERROR_SOURCE" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="SYREPID"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="CREATE" SCONAME="SOURC_TAB" VERSION="1" LANGU="E" DESCRIPT="SOURC_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_SOURT"/>
   <source>method CREATE.

    CLEAR error_source.

    CREATE OBJECT scanner.
    scanner-&gt;reset( ).

*   resolve includes ?
    IF resolve_includes = seox_true.
      scanner-&gt;resolve_includes( CHANGING sourc_tab = sourc_tab error_source = error_source ).
    ENDIF.
*   scan to get tokens and statements
    SCAN ABAP-SOURCE sourc_tab TOKENS     INTO scanner-&gt;me_priv-token_tab
                               STATEMENTS INTO scanner-&gt;me_priv-state_tab
                               WITH ANALYSIS.
    IF sy-subrc &lt;&gt; 0.
      CLEAR scanner.
      RETURN.
    ENDIF.

    scanner-&gt;me_priv-sourc_tab = sourc_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" VERSION="1" LANGU="E" DESCRIPT="INSERT_ALIAS" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ALIAS" SCONAME="ALIAS_TAB" VERSION="1" LANGU="E" DESCRIPT="ALIAS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ALIAT"/>
   <source>method INSERT_ALIAS.
* importing    state_pos type i
*              state_end type i
*              changing alias_tab type saboo_aliat.
    DATA:
      alias_rec    TYPE saboo_alias,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      state_length TYPE i,
      x1            TYPE i.
*   fill record with global data
    alias_rec-clsname    = me_priv-clsname.
    alias_rec-version    = me_priv-version.
    alias_rec-exposure   = me_priv-exposure.
*   set comp type of alias (1-attr ...)
    alias_rec-cmptype    = 9.            &quot; 9 is an invalid
*   length of statement
    state_length = state_end - state_pos + 1.
*   attribute declaration greater than ALIASES X.
    IF state_length = 4.
*     look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = state_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = state_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = state_pos + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     look for ALIASES .. FOR ..
      IF token_re2-str = &apos;FOR&apos;.
*       get name
        alias_rec-cmpname = token_re1-str.
*       get I~c
        SPLIT token_re3-str AT &apos;~&apos;
          INTO alias_rec-refclsname alias_rec-refcmpname.
*       write entry to admin table
        APPEND alias_rec TO alias_tab.
      ELSE.
*       syntax error or unsupported feature
*        raise resumable exception type statement_illegal.
      ENDIF.
    ELSE.
*     syntax error or unsupported feature
*      raise resumable exception type statement_illegal.
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" VERSION="1" LANGU="E" DESCRIPT="INSERT_ATTRI" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="ATTDECLTYP" VERSION="1" LANGU="E" DESCRIPT="ATTDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="ATTRI_TAB" VERSION="1" LANGU="E" DESCRIPT="ATTRI_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ATTRT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ATTRI" SCONAME="TYPSR_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPSR_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPST"/>
   <source>method INSERT_ATTRI.
*                  exporting value(attdecltyp) type n
*                            state_begin       type i
*                            state_end         type i
*                  changing  attri_tab         type saboo_attrt
*                            typsr_tab         type saboo_typst.
    DATA:
      attri_rec    TYPE saboo_attri,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      typsr_rec    TYPE saboo_typsr,
      cursor_left  TYPE i,
      cursor_right TYPE i,
      state_lenght TYPE i,
      x1            TYPE i,
      no_match     TYPE c,
      att_name(30) TYPE c,
      fl_size(30)  TYPE c.

* write default data for optional fields
    attri_rec-attvalue   = &apos;&apos;.
    attri_rec-typtype    = 1.
    attri_rec-type       = &apos;C&apos;.
    attri_rec-attdecltyp = attdecltyp.
* fill record with global data
    attri_rec-clsname    = me_priv-clsname.
    attri_rec-version    = me_priv-version.
    attri_rec-langu      = me_priv-langu.
    attri_rec-exposure   = me_priv-exposure.
    attri_rec-state      = me_priv-state.
    attri_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
* initialize state length, left and right cursor
    state_lenght = state_end - state_begin + 1.
    cursor_left  = state_begin + 1.
    cursor_right = state_end.
* attribute declaration greater than DATA X.
    IF state_lenght &gt; 2.
*   look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = cursor_left + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor_left + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = cursor_left + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? DATA x TYPE REF TO a ...
      IF ( state_lenght &gt;= 5 ) AND ( token_re1-str = &apos;TYPE&apos; ) AND
         ( token_re2-str = &apos;REF&apos; ) AND ( token_re3-str = &apos;TO&apos; ).
        x1 = cursor_left + 4.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        attri_rec-typtype = 3.
        attri_rec-type = token_re1-str.
        cursor_left       = cursor_left + 4.
*   ? DATA x TYPE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;TYPE&apos; ).
        attri_rec-typtype = 1.
        attri_rec-type = token_re2-str.
        cursor_left    = cursor_left + 2.
*   ? DATA x LIKE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;LIKE&apos; ).
        attri_rec-typtype = 0.
        attri_rec-type = token_re2-str.
        cursor_left    = cursor_left + 2.
*   ? BEGIN OF x | END OF x
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;OF&apos; ).
        CLEAR token_re1.
        x1 = cursor_left.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        CASE token_re1-str.
*       flag indis BEGIN ... END declaration
          WHEN &apos;BEGIN&apos;.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              me_priv-inside_begin_end = me_priv-inside_begin_end + 1.
            ELSE.
              me_priv-inside_begin_end = 1.
              me_priv-begin_end_row    = token_re1-row.
              me_priv-begin_end_col    = token_re1-col.
            ENDIF.
*       end of BEGIN .. END declaration write attribute and source table
          WHEN &apos;END&apos;.
*         END without BEGIN -&gt; error
            IF me_priv-inside_begin_end = 0.
*              raise resumable exception type statement_illegal.
              RETURN.
            ENDIF.
            me_priv-inside_begin_end = me_priv-inside_begin_end - 1.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              RETURN.
            ENDIF.
*         append to source table
            typsr_rec-clsname   = me_priv-clsname.
            typsr_rec-cmpname   = token_re2-str.
            typsr_rec-begin_row = me_priv-begin_end_row.
            typsr_rec-begin_col = me_priv-begin_end_col.
            typsr_rec-end_row   = token_re2-row.
            typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
            APPEND typsr_rec TO typsr_tab.
*         insert source
            me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = attri_rec-typesrc ).
*         append to attribute table
            attri_rec-cmpname = token_re2-str.
            attri_rec-typtype = 4.
            attri_rec-type    = space.
            APPEND attri_rec TO attri_tab.
        ENDCASE.
        RETURN.
      ENDIF.
*   ? inside a BGIN of x ... END of x declaration
      IF me_priv-inside_begin_end &gt; 0.
        RETURN.
      ENDIF.
*   look for additions, scan from right side
      WHILE ( cursor_left &lt; cursor_right ) AND
            ( no_match &lt;&gt; &apos;X&apos; ).
        state_lenght = cursor_right - cursor_left.
        CLEAR: token_re1, token_re2, token_re3.
        x1 = cursor_right - 2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        x1 = cursor_right - 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        x1 = cursor_right.
        READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     ? VALUE IS INITIAL
        IF ( state_lenght &gt;= 3 ) AND ( token_re1-str = &apos;VALUE&apos; ) AND
           ( token_re2-str = &apos;IS&apos; ) AND ( token_re3-str = &apos;INITIAL&apos; ).
          cursor_right = cursor_right - 3.
*     ? VALUE x
        ELSEIF ( state_lenght &gt;= 2 ) AND ( token_re2-str = &apos;VALUE&apos; ).
          attri_rec-attvalue = token_re3-str.
          cursor_right = cursor_right - 2.
*     ? READ-ONLY
        ELSEIF token_re3-str = &apos;READ-ONLY&apos;.
          attri_rec-attrdonly = &apos;X&apos;.
          cursor_right = cursor_right - 1.
*     ? BOXED
        ELSEIF token_re3-str = &apos;BOXED&apos;.
          attri_rec-typtype = 5.
          cursor_right = cursor_right - 1.
*     -&gt; no more additions
        ELSE.
          no_match = &apos;X&apos;.
        ENDIF.
      ENDWHILE.
    ELSE.
*   ? inside a BGIN of x ... END of x declaration
      IF me_priv-inside_begin_end &gt; 0.
        RETURN.
      ENDIF.
    ENDIF.
* get the name of attribute
    CLEAR: token_re1, att_name, fl_size.
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* ? xxx(yyy)
    SPLIT token_re1-str AT &apos;(&apos; INTO att_name fl_size.
    DATA dummy TYPE c LENGTH 1.                             &quot;#EC NEEDED
    SPLIT fl_size AT &apos;)&apos; INTO fl_size dummy.
    attri_rec-cmpname = att_name.
* ? complex type
    IF ( cursor_left &lt; cursor_right ) OR ( fl_size &lt;&gt; &apos;&apos; ).
*   fill and append record to type-source table
      CLEAR: token_re1, token_re2.
      x1 = state_begin + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor_right.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      typsr_rec-clsname   = me_priv-clsname.
      typsr_rec-cmpname   = att_name.
      typsr_rec-begin_row = token_re1-row.
      typsr_rec-begin_col = token_re1-col.
      typsr_rec-end_row   = token_re2-row.
      typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
      APPEND typsr_rec TO typsr_tab.
*   insert source
      me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = attri_rec-typesrc ).
*   update attribut record
      attri_rec-typtype = 4.
      attri_rec-type    = space.
    ENDIF.
    APPEND attri_rec TO attri_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" VERSION="1" LANGU="E" DESCRIPT="INSERT_CLASS" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="CLASS_TAB" VERSION="1" LANGU="E" DESCRIPT="CLASS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_CLAST"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="EXTED_TAB" VERSION="1" LANGU="E" DESCRIPT="EXTED_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EXTET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLASS" SCONAME="FRNDS_TAB" VERSION="1" LANGU="E" DESCRIPT="FRNDS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_FRNDT"/>
   <source>method INSERT_CLASS.
*   importing state_begin type i
*             state_end   type i
*   changing  class_tab   type saboo_clast
*             exted_tab   type saboo_extet
*             frnds_tab   type saboo_frndt.
    DATA:
      class_rec    TYPE saboo_class,
      exted_rec    TYPE saboo_exted,
      token_rec    TYPE saboo_tokesx,
      x1            TYPE i,
      y            TYPE i.

*   default values
    class_rec-exposure = 2. &quot;PUBLIC
*   get the name of the class
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
*   get name of class
    class_rec-clsname  = token_rec-str.
*   jump over DEFINITION
    x1 = x1 + 1.
*   look for additions
    WHILE x1 &lt; state_end.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
      CASE token_rec-str.
*       look for SHARED MEMORY ENABLED
        WHEN &apos;SHARED&apos;.
          y = state_end - x1.
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;MEMORY&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              IF token_rec-str = &apos;ENABLED&apos;.
                class_rec-clssharedmemory = &apos;X&apos;.
              ELSE.
                x1 = x1 - 2.
              ENDIF.
            ELSE.
              x1 = x1 - 1.
            ENDIF.
          ENDIF.
*       look for FOR TESTING
        WHEN &apos;FOR&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;TESTING&apos;.
              class_rec-with_unit_tests = abap_true.
            ENDIF.
          ENDIF.
*       look for DURATION SHORT/MEDIUM/LONG
        WHEN &apos;DURATION&apos;.
          y = state_end - x1.
*       there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            CASE token_rec-str.
              WHEN &apos;SHORT&apos;.
                class_rec-duration_type = const-aunit_duration-short.
              WHEN &apos;MEDIUM&apos;.
                class_rec-duration_type = const-aunit_duration-medium.
              WHEN &apos;LONG&apos;.
                class_rec-duration_type = const-aunit_duration-long.
            ENDCASE.
          ENDIF.
*       look for RISK LEVEL CRITICAL/DANGEROUS/HARMLESS
        WHEN &apos;RISK&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;LEVEL&apos;.
              y = state_end - x1.
*             there are enough tokens
              IF y &gt; 0.
                x1 = x1 + 1.
                READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
                CASE token_rec-str.
                  WHEN &apos;HARMLESS&apos;.
                    class_rec-risk_level = const-aunit_risk-harmless.
                  WHEN &apos;DANGEROUS&apos;.
                    class_rec-risk_level = const-aunit_risk-dangerous.
                  WHEN &apos;CRITICAL&apos;.
                    class_rec-risk_level = const-aunit_risk-critical.
                ENDCASE.
              ENDIF.
            ENDIF.
          ENDIF.
*       look for INHERITING FROM x
        WHEN &apos;INHERITING&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;FROM&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              exted_rec-clsname    = class_rec-clsname.
              exted_rec-refclsname = token_rec-str.
              exted_rec-state      = me_priv-state.
              APPEND exted_rec TO exted_tab.
              me_priv-superclsname = token_rec-str.
            ENDIF.
          ENDIF.
*       look for CREATE PUBLIC/PROTECTED/PACKAGE/PRIVATE
        WHEN &apos;CREATE&apos;.
          y = state_end - x1.
*         there are enough tokens
          IF y &gt; 0.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            CASE token_rec-str.
              WHEN &apos;PUBLIC&apos;.
                class_rec-exposure = 2.
              WHEN &apos;PROTECTED&apos;.
                class_rec-exposure = 1.
              WHEN &apos;PACKAGE&apos;.
                class_rec-exposure = 3.
              WHEN &apos;PRIVATE&apos;.
                class_rec-exposure = 0.
            ENDCASE.
          ENDIF.
*       look for ABSTRACT
        WHEN &apos;ABSTRACT&apos;.
          class_rec-clsabstrct = &apos;X&apos;.
*       look for FINAL
        WHEN &apos;FINAL&apos;.
          class_rec-clsfinal = &apos;X&apos;.
*       look for FRIENDS
        WHEN &apos;FRIENDS&apos;.
          x1 = x1 + 1.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = class_rec-clsname
              state_pos = x1
              state_end = state_end
            CHANGING
              frnds_tab = frnds_tab ).
          x1 = state_end.
*       look for GLOBAL FRIENDS
        WHEN &apos;GLOBAL&apos;.
          x1 = x1 + 2.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = class_rec-clsname
              state_pos = x1
              state_end = state_end
            CHANGING
              frnds_tab = frnds_tab ).
          x1 = state_end.
*       look for PUBLIC (just in case an already global class is scanned)
        WHEN &apos;PUBLIC&apos;.
*         ignore PUBLIC for global classes
*       look for SHARED MEMORY ENABLED
        WHEN &apos;OPEN&apos;.
          y = state_end - x1.
          IF y &gt; 1.
            x1 = x1 + 1.
            READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
            IF token_rec-str = &apos;FOR&apos;.
              x1 = x1 + 1.
              READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
              IF token_rec-str = &apos;PACKAGE&apos;.
*                class_rec-within_package = &apos;X&apos;.
              ELSE.
                x1 = x1 - 2.
              ENDIF.
            ELSE.
              x1 = x1 - 1.
            ENDIF.
          ENDIF.
      ENDCASE.
    ENDWHILE.
*   fill record and append it to table
    class_rec-version  = me_priv-version.
    class_rec-langu    = me_priv-langu.
    class_rec-state    = me_priv-state.
    class_rec-fixpt    = abap_true.
    APPEND class_rec TO class_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" VERSION="1" LANGU="E" DESCRIPT="INSERT_CLOAD" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_CLOAD" SCONAME="CLOAD_TAB" VERSION="1" LANGU="E" DESCRIPT="CLOAD_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_CLOAT"/>
   <source>method INSERT_CLOAD.
*   importing state_pos type i
*   changing  cload_tab type saboo_cloat.
    DATA:
      cload_rec TYPE saboo_cload,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    cload_rec-clsname   = me_priv-clsname.
    cload_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND cload_rec TO cload_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" VERSION="1" LANGU="E" DESCRIPT="INSERT_EPARA" EXPOSURE="0" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EPARA" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method INSERT_EPARA.
*  importing state_end type i
*  changing  curre_pos type i
*            epara_tab type saboo_epart.
    DATA:
      token_rec TYPE saboo_tokesx.

* look for exporting parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;EXPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_epara(
        EXPORTING
          pardecltyp = 1
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          epara_tab  = epara_tab ).
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" VERSION="1" LANGU="E" DESCRIPT="INSERT_EVENT" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EVTDECLTYP" VERSION="1" LANGU="E" DESCRIPT="EVTDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EVENT_TAB" VERSION="1" LANGU="E" DESCRIPT="EVENT_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EVENT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_EVENT" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method INSERT_EVENT.
*   importing value(evtdecltyp) type n
*             state_pos         type i
*             state_end         type i
*   changing  event_tab         type saboo_event
*             epara_tab         type saboo_epart.
    DATA:
      event_rec TYPE saboo_evenx,
      token_re1 TYPE saboo_tokesx,
      curre_pos TYPE i,
      x1         TYPE i.

*   write default data for optional fields
    event_rec-redefin    = &apos; &apos;.
*   write kind of event
    event_rec-evtdecltyp = evtdecltyp.
*   get the name of event
    CLEAR token_re1.
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    event_rec-cmpname = token_re1-str.
*   inside a event valid
    me_priv-cmpname = token_re1-str.
    curre_pos = state_pos + 2.
*   look for redefinition of event
    CLEAR token_re1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_re1-str = &apos;REDEFINITION&apos; ).
      event_rec-redefin = &apos;X&apos;.
      curre_pos = curre_pos + 1.
    ENDIF.
*   fill record with global data and append it to table
    event_rec-clsname   = me_priv-clsname.
    event_rec-version   = me_priv-version.
    event_rec-langu     = me_priv-langu.
    event_rec-exposure  = me_priv-exposure.
    event_rec-state     = me_priv-state.
    event_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
    APPEND event_rec TO event_tab.
*   look for parameters
    IF curre_pos &lt;= state_end.
      me-&gt;insert_epara(
        EXPORTING
          state_end = state_end
        CHANGING
          curre_pos = curre_pos
          epara_tab = epara_tab ).
    ENDIF.
*   outside a event invalid
    me_priv-cmpname  = &apos;*** void ***&apos;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" VERSION="1" LANGU="E" DESCRIPT="INSERT_FRNDS" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="CLSNAME" VERSION="1" LANGU="E" DESCRIPT="CLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CSEQUENCE"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_FRNDS" SCONAME="FRNDS_TAB" VERSION="1" LANGU="E" DESCRIPT="FRNDS_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_FRNDT"/>
   <source>method INSERT_FRNDS.
*   importing clsname type csequence
*             state_pos type i
*             state_end type i
*   changing  frnds_tab type saboo_frndt.

    DATA:
      x1         TYPE i,
      frnds_rec TYPE saboo_frnds,
      token_re1 TYPE saboo_tokesx.

* fill global components
    frnds_rec-clsname    = clsname.
    frnds_rec-friendtype = 0. &quot;insert always global friends
    frnds_rec-state      = me_priv-state.
    frnds_rec-version    = me_priv-version.
* loop over all classes/interfaces
    x1 = state_pos.
    WHILE x1 &lt;= state_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      frnds_rec-refclsname = token_re1-str.
      APPEND frnds_rec TO frnds_tab.
      x1 = x1 + 1.
    ENDWHILE.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" VERSION="1" LANGU="E" DESCRIPT="INSERT_IIMPL" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="IIMPL_TAB" VERSION="1" LANGU="E" DESCRIPT="IIMPL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_IIMPT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IIMPL" SCONAME="REDEF_TAB" VERSION="1" LANGU="E" DESCRIPT="REDEF_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_REDET"/>
   <source>method INSERT_IIMPL.
*   importing state_pos type i
*             state_end type i
*   changing  iimpl_tab type saboo_iimpt
*             redef_tab type saboo_redet.

    DATA: iimpl_rec   TYPE saboo_iimpl,
          redef_rec   TYPE saboo_redef,
          token_re1   TYPE saboo_tokesx,
          token_re2   TYPE saboo_tokesx,
          token_re3   TYPE saboo_tokesx,
          x1           TYPE i,
          y           TYPE i,
          z           TYPE i,
          addition(1) TYPE c.

*   get name of interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    iimpl_rec-refclsname = token_re1-str.
*   addition ABSTRACT/FINAL METHODS / ALL METHODS / DATA VALUE
    WHILE x1 &lt; state_end.
      y = state_end - x1.
      IF y &gt; 2.
*       look for stop words ABSTRACT/FINAL METHODS/ALL METHODS/DATA VALUE
        z = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX z.
        z = z + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX z.
        IF token_re1-str = &apos;ABSTRACT&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;A&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;FINAL&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;F&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;ALL&apos; AND token_re2-str = &apos;METHODS&apos;.
          addition = &apos;M&apos;. x1 = z.
        ELSEIF token_re1-str = &apos;DATA&apos; AND token_re2-str = &apos;VALUES&apos;.
          addition = &apos;D&apos;. x1 = z.
        ENDIF.
      ENDIF.
*     depending on addition parse parameter
      CASE addition.
        WHEN &apos;A&apos;.
*         add ABSTRACT METHODS ... x ...
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*         fill redefinition table
          CLEAR redef_rec.
          redef_rec-clsname    = me_priv-clsname.
          redef_rec-version    = me_priv-version.
          redef_rec-refclsname = iimpl_rec-refclsname.
          redef_rec-mtdname    = token_re1-str.
          redef_rec-mtdabstrct = &apos;X&apos;.
          redef_rec-mtdfinal   = &apos;&apos;.
          redef_rec-attvalue   = &apos;&apos;.
          APPEND redef_rec TO redef_tab.
        WHEN &apos;F&apos;.
*         add FINAL METHODS ... x ...
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*         fill redefinition table
          CLEAR redef_rec.
          redef_rec-clsname    = me_priv-clsname.
          redef_rec-version    = me_priv-version.
          redef_rec-refclsname = iimpl_rec-refclsname.
          redef_rec-mtdname    = token_re1-str.
          redef_rec-mtdabstrct = &apos;&apos;.
          redef_rec-mtdfinal   = &apos;X&apos;.
          redef_rec-attvalue   = &apos;&apos;.
          APPEND redef_rec TO redef_tab.
        WHEN &apos;M&apos;.
*         add ALL METHODS ABSTARCT|FINAL
          ADD 1 TO x1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
          IF token_re1-str = &apos;ABSTRACT&apos;.
            iimpl_rec-impabstrct = &apos;X&apos;.
          ELSEIF token_re1-str = &apos;FINAL&apos;.
            iimpl_rec-impfinal = &apos;X&apos;.
          ENDIF.
*         ALL METHODS does not have a parameter list
          addition = &apos; &apos;.
        WHEN &apos;D&apos;.
*         add DATA VALUE x = y
          y = state_end - x1.
          IF y &gt; 2.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
            ADD 1 TO x1.
            READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
            IF token_re2-str = &apos;=&apos;.
*             fill redefinition table
              CLEAR redef_rec.
              redef_rec-clsname    = me_priv-clsname.
              redef_rec-version    = me_priv-version.
              redef_rec-refclsname = iimpl_rec-refclsname.
              redef_rec-mtdname    = token_re1-str.
              redef_rec-mtdabstrct = &apos;&apos;.
              redef_rec-mtdfinal   = &apos;&apos;.
              redef_rec-attvalue   =  token_re3-str.
              APPEND redef_rec TO redef_tab.
            ELSE.
*             every list entry has to have the format x = y
              addition = &apos; &apos;.
            ENDIF.
          ELSE.
*           every list entry has to have the format x = y
            addition = &apos; &apos;.
          ENDIF.
        WHEN OTHERS.
*         in case you could not recognize a new addition, go ahead
          ADD 1 TO x1.
      ENDCASE.
    ENDWHILE.
*   write global data
    iimpl_rec-clsname   = me_priv-clsname.
    iimpl_rec-version   = me_priv-version.
    iimpl_rec-exposure  = me_priv-exposure.
    iimpl_rec-state     = me_priv-state.
*    iimpl_rec-editorder = me_priv-editor_order. add 1 to me_priv-editor_order.
*   append to tab
    APPEND iimpl_rec TO iimpl_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" VERSION="1" LANGU="E" DESCRIPT="INSERT_IINCL" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_IINCL" SCONAME="IINCL_TAB" VERSION="1" LANGU="E" DESCRIPT="IINCL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_IINCT"/>
   <source>method INSERT_IINCL.
*   importing state_pos type i
*   changing  iincl_tab type saboo_iinct.

    DATA: iincl_rec TYPE saboo_iincl,
          token_rec TYPE saboo_tokesx,
          x1         TYPE i.

* get name of interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
    iincl_rec-refclsname = token_rec-str.
* no more to do for now
* write global data
    iincl_rec-clsname  = me_priv-clsname.
    iincl_rec-version  = me_priv-version.
    iincl_rec-state    = me_priv-state.
* append to tab
    APPEND iincl_rec TO iincl_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" VERSION="1" LANGU="E" DESCRIPT="INSERT_ILOAD" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_ILOAD" SCONAME="ILOAD_TAB" VERSION="1" LANGU="E" DESCRIPT="ILOAD_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_ILOAT"/>
   <source>method INSERT_ILOAD.
* importing state_pos type i
* changing  iload_tab type saboo_iloat.

    DATA:
      iload_rec TYPE saboo_iload,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    iload_rec-clsname   = me_priv-clsname.
    iload_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND iload_rec TO iload_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" VERSION="1" LANGU="E" DESCRIPT="INSERT_INTER" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_INTER" SCONAME="INTER_TAB" VERSION="1" LANGU="E" DESCRIPT="INTER_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_INTET"/>
   <source>method INSERT_INTER.
*   importing state_pos type i
*   changing  inter_tab type saboo_intet.
    DATA:
      inter_rec TYPE saboo_inter,
      token_rec TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of the interface
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_rec INDEX x1.
* fill record and append it to table
    inter_rec-clsname  = token_rec-str.
    inter_rec-version  = me_priv-version.
    inter_rec-langu    = me_priv-langu.
    inter_rec-exposure = me_priv-exposure.
    inter_rec-state    = me_priv-state.
    APPEND inter_rec TO inter_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" VERSION="1" LANGU="E" DESCRIPT="INSERT_METHO" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MTDDECLTYP" VERSION="1" LANGU="E" DESCRIPT="MTDDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="METHO_TAB" VERSION="1" LANGU="E" DESCRIPT="METHO_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_METHT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="REDEF_TAB" VERSION="1" LANGU="E" DESCRIPT="REDEF_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_REDET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_METHO" SCONAME="MEXCE_TAB" VERSION="1" LANGU="E" DESCRIPT="MEXCE_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MEXCT"/>
   <source>method INSERT_METHO.
*   importing value(mtddecltyp) type n
*             state_pos         type i
*             state_end         type i
*   changing  metho_tab         type saboo_metht
*             redef_tab         type saboo_redet
*             mpara_tab         type saboo_mpart
*             mexce_tab         type saboo_mexct.
    DATA:
      metho_rec TYPE saboo_metho,
      mpara_rec TYPE saboo_mpara,
      redef_rec TYPE saboo_redef,
      token_re1 TYPE saboo_tokesx,
      token_re2 TYPE saboo_tokesx,
      token_re3 TYPE saboo_tokesx,
      curre_pos TYPE i,
      x1         TYPE i.

* write default data for optional fields
    metho_rec-redefin    = &apos; &apos;.
    metho_rec-mtdabstrct = &apos; &apos;.
    metho_rec-mtdfinal   = &apos; &apos;.
* metho_rec-desnoteom  = &apos; &apos;.
    metho_rec-mtdtype    = 0.
    me_priv-mtdtype    = 0.
    metho_rec-refclsname = &apos;&apos;.
    metho_rec-refcmpname = &apos;&apos;.
* write kind of method
    metho_rec-mtddecltyp = mtddecltyp.
* get the name of method
    CLEAR token_re1.
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
    metho_rec-cmpname = token_re1-str.
    IF metho_rec-cmpname = &apos;CONSTRUCTOR&apos; OR  metho_rec-cmpname = &apos;CLASS_CONSTRUCTOR&apos;.
      metho_rec-mtdtype    = 2.
      me_priv-mtdtype    = 2.
    ELSEIF  metho_rec-cmpname = &apos;DESTRUCTOR&apos;.
      metho_rec-mtdtype    = 3.
      me_priv-mtdtype    = 3.
    ENDIF.
* inside a method valid
    me_priv-cmpname = token_re1-str.
    curre_pos = state_pos + 2.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
    x1 = curre_pos + 1.
    CLEAR token_re3.
    READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
* look for abstract method
    IF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;ABSTRACT&apos; ).
      metho_rec-mtdabstrct = &apos;X&apos;.
      redef_rec-mtdabstrct = &apos;X&apos;.
      curre_pos = curre_pos + 1.
* look for final method
    ELSEIF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;FINAL&apos; ).
      metho_rec-mtdfinal = &apos;X&apos;.
      redef_rec-mtdfinal = &apos;X&apos;.
      curre_pos = curre_pos + 1.
* look for DESTRUCTOR NOT AT END OF MODE
    ELSEIF ( curre_pos &lt;= state_end ) AND
           ( token_re1-str = &apos;DESTRUCTOR&apos; ) AND
           ( token_re2-str = &apos;NOT&apos; ) AND ( token_re3-str = &apos;AT&apos; ).
      x1 = curre_pos + 2.
      CLEAR token_re1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = curre_pos + 3.
      CLEAR token_re2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 4.
      CLEAR token_re3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
      IF ( token_re1-str = &apos;END&apos; ) AND ( token_re2-str = &apos;OF&apos; ) AND
         ( token_re3-str = &apos;MODE&apos; ).
        metho_rec-dsrnoteom = &apos;X&apos;.
        ADD 5 TO curre_pos.
      ENDIF.
    ENDIF.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
    x1 = curre_pos + 1.
    CLEAR token_re3.
    READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
* look for testing
    IF ( token_re2-str = &apos;FOR&apos; ) AND ( token_re3-str = &apos;TESTING&apos; ).
      metho_rec-mtdtype    = 6.
      me_priv-mtdtype    = 6.
      curre_pos = curre_pos + 2.
    ENDIF.
    CLEAR token_re2.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX curre_pos.
* look for redefinition of method
    IF ( curre_pos &lt;= state_end ) AND ( token_re2-str = &apos;REDEFINITION&apos; ).
*   for redefinitions we only fill redef_tab !!
      redef_rec-clsname    = me_priv-clsname.
      redef_rec-refclsname = me_priv-superclsname.
      redef_rec-mtdname    = token_re1-str.
      APPEND redef_rec TO redef_tab.
      RETURN.
    ENDIF.
* ? event method FOR EVENT
    CLEAR: token_re1, token_re2.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
    x1 = curre_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
* ? enough tokens left
    x1 = curre_pos + 4.
    IF ( x1 &lt;= state_end ) AND
       ( token_re1-str = &apos;FOR&apos; ) AND ( token_re2-str = &apos;EVENT&apos; ).
      CLEAR: token_re1, token_re2, token_re3.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = curre_pos + 3.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 4.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? FOR EVENT x OF y
      IF ( token_re2-str = &apos;OF&apos; ).
        metho_rec-refclsname = token_re3-str.
        SPLIT token_re1-str AT &apos;~&apos;
          INTO metho_rec-refintname
          metho_rec-refcmpname.
        IF metho_rec-refcmpname = &apos;&apos;.
          metho_rec-refcmpname = metho_rec-refintname.
          metho_rec-refintname = &apos;&apos;.
        ENDIF.
        metho_rec-mtdtype    = 1.
        me_priv-mtdtype    = 1.
        curre_pos = curre_pos + 5.
        IF curre_pos &lt;= state_end.
*       read next token
          CLEAR token_re1.
          READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
*       scan for IMPORTING
          IF ( curre_pos &lt;= state_end ) AND
             ( token_re1-str = &apos;IMPORTING&apos; ).
            curre_pos = curre_pos + 1.
*         scan for handler parameter
            WHILE curre_pos &lt;= state_end.
*           read next token
              CLEAR token_re1.
              READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
*           fill name and type of parameter
              mpara_rec-sconame    = token_re1-str.
              mpara_rec-parpasstyp = 0.
              mpara_rec-pardecltyp = 0.
              mpara_rec-typtype    = 0.
*           fill global record and append it
              mpara_rec-clsname    = me_priv-clsname.
              mpara_rec-cmpname    = me_priv-cmpname.
              mpara_rec-version    = me_priv-version.
              mpara_rec-langu      = me_priv-langu.
              mpara_rec-mtdtype    = me_priv-mtdtype.
              APPEND mpara_rec TO mpara_tab.
              curre_pos = curre_pos + 1.
            ENDWHILE.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSE.
*   look for parameters
      IF curre_pos &lt;= state_end.
        me-&gt;insert_mpara(
          EXPORTING
            state_end = state_end
          CHANGING
            curre_pos = curre_pos
            mpara_tab = mpara_tab ).
      ENDIF.
*   look for exceptions
      IF curre_pos &lt;= state_end.
        me-&gt;insert_mexec(
          EXPORTING
            state_end = state_end
          CHANGING
            curre_pos = curre_pos
            mtdnewexc = metho_rec-mtdnewexc
            mexce_tab = mexce_tab ).
      ENDIF.
    ENDIF.
* fill record with global data and append it to table
    metho_rec-clsname    = me_priv-clsname.
    metho_rec-version    = me_priv-version.
    metho_rec-langu      = me_priv-langu.
    metho_rec-exposure   = me_priv-exposure.
    metho_rec-state      = me_priv-state.
    metho_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
    APPEND metho_rec TO metho_tab.
* outside a method invalid
    me_priv-cmpname  = &apos;*** void ***&apos;.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" VERSION="1" LANGU="E" DESCRIPT="INSERT_MEXEC" EXPOSURE="0" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="MTDNEWEXC" VERSION="1" LANGU="E" DESCRIPT="MTDNEWEXC" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SEONEWEXC"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MEXEC" SCONAME="MEXCE_TAB" VERSION="1" LANGU="E" DESCRIPT="MEXCE_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MEXCT"/>
   <source>method INSERT_MEXEC.
*   importing state_end type i
*   changing  curre_pos type i
*             mtdnewexc type seonewexc
*             mexce_tab type saboo_mexct.

    DATA:
      excp_name TYPE c LENGTH 30,
      mexce_rec TYPE saboo_mexce,
      token_rec TYPE saboo_tokesx.

    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
* ? RAISING ....
    IF token_rec-str = &apos;RAISING&apos;.
      mtdnewexc = &apos;X&apos;.
    ELSE.
      mtdnewexc = &apos;&apos;.
    ENDIF.
* ? EXCEPTIONS ... or RAISING ...
    IF token_rec-str = &apos;EXCEPTIONS&apos; OR mtdnewexc = &apos;X&apos;.
      DO.
        curre_pos = curre_pos + 1.
*     ? end of statement
        IF curre_pos &gt; state_end.
          EXIT.
        ENDIF.
*     read exception name
        CLEAR: token_rec, mexce_rec.
        READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
*     fill record and append it
        IF strlen( token_rec-str ) &gt; 12 AND token_rec-str(10) = &apos;RESUMABLE(&apos;.
          DATA dummy TYPE c LENGTH 1.                       &quot;#EC NEEDED
          SPLIT token_rec-str+10(*) AT &apos;)&apos; INTO excp_name dummy.
          mexce_rec-is_resumable = abap_true.
        ELSE.
          mexce_rec-is_resumable = abap_false.
          excp_name = token_rec-str.
        ENDIF.
        mexce_rec-sconame   = excp_name.
        mexce_rec-clsname   = me_priv-clsname.
        mexce_rec-cmpname   = me_priv-cmpname.
        mexce_rec-version   = me_priv-version.
        mexce_rec-langu     = me_priv-langu.
        mexce_rec-mtdtype   = me_priv-mtdtype.
        mexce_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
        APPEND mexce_rec TO mexce_tab.
      ENDDO.
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" VERSION="1" LANGU="E" DESCRIPT="INSERT_MPARA" EXPOSURE="0" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_MPARA" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <source>method INSERT_MPARA.
*   importing state_end type i
*   changing  curre_pos type i
*             mpara_tab type saboo_mpart.

    DATA:
      token_rec TYPE saboo_tokesx.

* look for importing parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;IMPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 0
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for exporting parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;EXPORTING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 1
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for changing parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;CHANGING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 2
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
* look for returning parameters
    CLEAR token_rec.
    READ TABLE me_priv-token_tab INTO token_rec INDEX curre_pos.
    IF ( curre_pos &lt;= state_end ) AND ( token_rec-str = &apos;RETURNING&apos; ).
      curre_pos = curre_pos + 1.
      me-&gt;write_mpara(
        EXPORTING
          pardecltyp = 3
          state_end  = state_end
        CHANGING
          curre_pos  = curre_pos
          mpara_tab  = mpara_tab ).
    ENDIF.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" VERSION="1" LANGU="E" DESCRIPT="INSERT_TPOOL" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" SCONAME="STATE_POS" VERSION="1" LANGU="E" DESCRIPT="STATE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TPOOL" SCONAME="TPOOL_TAB" VERSION="1" LANGU="E" DESCRIPT="TPOOL_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TPOOT"/>
   <source>method INSERT_TPOOL.
*    importing state_pos type i
*    changing  tpool_tab type saboo_tpoot.

    DATA:
      tpool_rec TYPE saboo_tpool,
      token_re1 TYPE saboo_tokesx,
      x1         TYPE i.

* get the name of CLASS x DEFINITION LOAD
    x1 = state_pos + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* fill record
    tpool_rec-clsname   = me_priv-clsname.
    tpool_rec-typegroup = token_re1-str.
* write entry to admin table
    APPEND tpool_rec TO tpool_tab.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" VERSION="1" LANGU="E" DESCRIPT="INSERT_TYPES" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="STATE_BEGIN" VERSION="1" LANGU="E" DESCRIPT="STATE_BEGIN" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="TYPES_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPES_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPET"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="INSERT_TYPES" SCONAME="TYPSR_TAB" VERSION="1" LANGU="E" DESCRIPT="TYPSR_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPST"/>
   <source>method INSERT_TYPES.
*   importing state_begin       type i
*             state_end         type i
*   changing  types_tab         type saboo_typet
*             typsr_tab         type saboo_typst.
    DATA:
      types_rec    TYPE saboo_types,
      token_re1    TYPE saboo_tokesx,
      token_re2    TYPE saboo_tokesx,
      token_re3    TYPE saboo_tokesx,
      typsr_rec    TYPE saboo_typsr,
      cursor       TYPE i,
      state_lenght TYPE i,
      x1            TYPE i,
      typ_name(30) TYPE c,
      fl_size(30)  TYPE c.

* write default data for optional fields
    types_rec-typtype    = 1.
    types_rec-type       = &apos;C&apos;.
* fill record with global data
    types_rec-clsname   = me_priv-clsname.
    types_rec-version   = me_priv-version.
    types_rec-langu     = me_priv-langu.
    types_rec-exposure  = me_priv-exposure.
    types_rec-state     = me_priv-state.
    types_rec-editorder = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
* initialize state length, left and right cursor
    state_lenght = state_end - state_begin + 1.
    cursor = state_begin + 1.
* type declaration greater than TYPES X.
    IF state_lenght &gt; 2.
*   look for type, scan from left side
      CLEAR: token_re1, token_re2, token_re3.
      x1 = cursor + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = cursor + 2.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = cursor + 3.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? TYPES x TYPE REF TO a ...
      IF ( state_lenght &gt;= 5 ) AND ( token_re1-str = &apos;TYPE&apos; ) AND
         ( token_re2-str = &apos;REF&apos; ) AND ( token_re3-str = &apos;TO&apos; ).
        x1 = cursor + 4.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        types_rec-typtype = 3.
        types_rec-type    = token_re1-str.
        cursor            = cursor + 4.
*   ? TYPES x TYPE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;TYPE&apos; ).
        types_rec-typtype = 1.
        types_rec-type    = token_re2-str.
        cursor            = cursor + 2.
*   ? DATA x LIKE a ...
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;LIKE&apos; ).
        types_rec-typtype = 0.
        types_rec-type    = token_re2-str.
        cursor            = cursor + 2.
*   ? BEGIN OF x | END OF x
      ELSEIF ( state_lenght &gt;= 4 ) AND ( token_re1-str = &apos;OF&apos; ).
        CLEAR token_re1.
        x1 = cursor.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        CASE token_re1-str.
*       flag inside BEGIN ... END declaration
          WHEN &apos;BEGIN&apos;.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              me_priv-inside_begin_end = me_priv-inside_begin_end + 1.
            ELSE.
              me_priv-inside_begin_end = 1.
              me_priv-begin_end_row    = token_re1-row.
              me_priv-begin_end_col    = token_re1-col.
            ENDIF.
*       end of BEGIN .. END declaration write attribute and source table
          WHEN &apos;END&apos;.
*         END without BEGIN -&gt; error
            IF me_priv-inside_begin_end = 0.
*              raise resumable exception type statement_illegal.
              RETURN.
            ENDIF.
            me_priv-inside_begin_end = me_priv-inside_begin_end - 1.
*         ? nested BEGIN ... END
            IF me_priv-inside_begin_end &gt; 0.
              RETURN.
            ENDIF.
*         append to source table
            typsr_rec-clsname   = me_priv-clsname.
            typsr_rec-cmpname   = token_re2-str.
            typsr_rec-begin_row = me_priv-begin_end_row.
            typsr_rec-begin_col = me_priv-begin_end_col.
            typsr_rec-end_row   = token_re2-row.
            typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
            APPEND typsr_rec TO typsr_tab.
*         insert source
            me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = types_rec-typesrc ).
*         append to attribute table
            types_rec-cmpname = token_re2-str.
            types_rec-typtype = 4.
            types_rec-type    = space.
            APPEND types_rec TO types_tab.
        ENDCASE.
        RETURN.
      ENDIF.
    ENDIF.
* ? inside a BGIN of x ... END of x declaration
    IF me_priv-inside_begin_end &gt; 0.
      RETURN.
    ENDIF.
* get the name of attribute
    CLEAR: token_re1, typ_name, fl_size.
    x1 = state_begin + 1.
    READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
* ? xxx(yyy)
    SPLIT token_re1-str AT &apos;(&apos; INTO typ_name fl_size.
    DATA dummy TYPE c LENGTH 1.                             &quot;#EC NEEDED
    SPLIT fl_size AT &apos;)&apos; INTO fl_size dummy.
    types_rec-cmpname = typ_name.
* ? complex type
    IF ( cursor &lt; state_end ) OR ( fl_size &lt;&gt; &apos;&apos; ).
*   fill and append record to type-source table
      CLEAR: token_re1, token_re2.
      x1 = state_begin + 1.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = state_end.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      typsr_rec-clsname   = me_priv-clsname.
      typsr_rec-cmpname   = typ_name.
      typsr_rec-begin_row = token_re1-row.
      typsr_rec-begin_col = token_re1-col.
      typsr_rec-end_row   = token_re2-row.
      typsr_rec-end_col   = token_re2-col + strlen( token_re2-str ) - 1.
      APPEND typsr_rec TO typsr_tab.
*   insert source
      me-&gt;source_tab_to_char( EXPORTING typsr_rec = typsr_rec CHANGING char = types_rec-typesrc ).
*   update attribut record
      types_rec-typtype = 4.
      types_rec-type    = space.
    ENDIF.
* append record to attribute table
    APPEND types_rec TO types_tab.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESET" VERSION="1" LANGU="E" DESCRIPT="RESET" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method RESET.
    me_priv-clsname           = &apos;*** void ***&apos;. &quot; outside a definition invalid
    me_priv-superclsname      = &apos;*** void ***&apos;. &quot; outside a definition invalid
    me_priv-cmpname           = &apos;*** void ***&apos;. &quot; outside method/event invalid
    me_priv-version           = 1.              &quot; default is ACTIV
    me_priv-langu             = sy-langu.       &quot; get system langage
    me_priv-exposure          = const-exposure-public.&quot; default is PUBLIC
    me_priv-state             = 1.              &quot; default is impl. and not modl.
    me_priv-mtdtype           = 0.              &quot; default normal method
    me_priv-editor_order      = 1.              &quot; reset counter for editor order
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" VERSION="1" LANGU="E" DESCRIPT="RESOLVE_INCLUDES" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" SCONAME="SOURC_TAB" VERSION="1" LANGU="E" DESCRIPT="SOURC_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_SOURT"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="RESOLVE_INCLUDES" SCONAME="ERROR_SOURCE" VERSION="1" LANGU="E" DESCRIPT="ERROR_SOURCE" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SYST-REPID"/>
   <source>method RESOLVE_INCLUDES.
*   changing p_sourc_tab type saboo_sourt
*            p_error_source type syst-repid.

    TYPES: BEGIN OF include_ret,
             statement  TYPE saboo_state,
             sourc_tab  TYPE saboo_sourt,
           END OF include_ret,
           include_tat TYPE STANDARD TABLE OF include_ret WITH DEFAULT KEY.

    DATA: prog_tab    TYPE saboo_sourt,
          sourl_tab   TYPE saboo_sourt,
          token_rec   TYPE saboo_tokes,
          index       TYPE i,
          index2      TYPE i,
          include_tab TYPE include_tat,
          include_wa  TYPE include_ret,
          lstate_tab   TYPE saboo_statt,
          ltoken_tab   TYPE saboo_tokst,
          incl_name(40) TYPE c.

    FIELD-SYMBOLS: &lt;state_wa&gt;   TYPE saboo_state,
                   &lt;include_wa&gt; TYPE include_ret.

*   scan to get tokens and statements
    SCAN ABAP-SOURCE sourc_tab TOKENS     INTO ltoken_tab
                               STATEMENTS INTO lstate_tab.
*   look for INCLUDE statements
    LOOP AT lstate_tab ASSIGNING &lt;state_wa&gt; WHERE type = &apos;I&apos;.
*     read second token (name of program to by included)
      index = &lt;state_wa&gt;-to.
      READ TABLE ltoken_tab INTO token_rec INDEX index.
*     read program and append to source table
      CLEAR: prog_tab.
      incl_name = token_rec-str.
      CLEAR prog_tab.
      READ REPORT incl_name INTO prog_tab.
      APPEND LINES OF prog_tab TO sourl_tab.
*     the last statement has terminator . (chained-statement ,)
      IF &lt;state_wa&gt;-terminator = &apos;.&apos;.
*       recursive descent
        me-&gt;resolve_includes( CHANGING sourc_tab = sourl_tab error_source = error_source ).
*       append include source to include table
        include_wa-statement = &lt;state_wa&gt;.
        include_wa-sourc_tab = sourl_tab.
        INSERT include_wa INTO include_tab INDEX 1.
*       refresh source collection table
        CLEAR: sourl_tab.
      ENDIF.
    ENDLOOP.
*   insert source from includes to source tabel
    LOOP AT include_tab ASSIGNING &lt;include_wa&gt;.
*     delete INCLUDE statements
      READ TABLE ltoken_tab INTO token_rec
        INDEX &lt;include_wa&gt;-statement-from.
      index  = token_rec-row.
      READ TABLE ltoken_tab INTO token_rec
        INDEX &lt;include_wa&gt;-statement-to.
      index2 = token_rec-row.
      DELETE sourc_tab FROM index TO index2.
*     insert include source
      INSERT LINES OF &lt;include_wa&gt;-sourc_tab
        INTO sourc_tab INDEX index.
    ENDLOOP.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" VERSION="1" LANGU="E" DESCRIPT="SCAN_SOURCE" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="CLSNAME" VERSION="1" LANGU="E" DESCRIPT="CLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLASS-CLSNAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="SUPERCLSNAME" VERSION="1" LANGU="E" DESCRIPT="SUPERCLSNAME" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLASS-CLSNAME" PAROPTIONL="X"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="EXPOSURE" VERSION="1" LANGU="E" DESCRIPT="EXPOSURE" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOCLASS-EXPOSURE" PARVALUE="2"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE" SCONAME="VSEO_TABS" VERSION="1" LANGU="E" DESCRIPT="VSEO_TABS" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>method SCAN_SOURCE.

    DATA:
      token_re1 TYPE saboo_tokesx,
      token_re2 TYPE saboo_tokesx,
      token_re3 TYPE saboo_tokesx,
      state_rec TYPE saboo_state,
      state_len TYPE i,
      x1        TYPE i,
      scope_rec TYPE scope_rec_type.

    me-&gt;reset( ).

*   set class context, if passed
    IF clsname IS NOT INITIAL.
      me_priv-clsname  = clsname.
      IF superclsname IS NOT INITIAL.
        me_priv-superclsname = superclsname.
      ENDIF.
      me_priv-exposure = exposure.
*     increase the nested scope because we are inside a definition
      me_priv-nested_sc = me_priv-nested_sc + 1.
      scope_rec-clsname  = clsname.
      scope_rec-exposure = exposure.
      INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
    ENDIF.

*   main loop to fill all tables
    LOOP AT me_priv-state_tab INTO state_rec.
*     no empty statements
      CHECK state_rec-from &lt;= state_rec-to.
      state_len = state_rec-to - state_rec-from + 1.
*     get the first three tokens, if available
      CLEAR: token_re1, token_re2, token_re3.
      x1 = state_rec-from.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = x1 + 1.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*     look for CLASS X DEFINITION statement
      IF ( token_re1-str = &apos;CLASS&apos; ) AND
         ( token_re3-str = &apos;DEFINITION&apos; ).
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
*       CLASS xxx DEFINITION DEFERRED.
        IF state_len = 4 AND token_re1-str = &apos;DEFERRED&apos;.
*       ignore
*       CLASS xxx DEFINITION LOAD.
        ELSEIF state_len = 4 AND token_re1-str = &apos;LOAD&apos;.
          IF me_priv-nested_sc &gt; 0.
*         CLASS x DEFINITION LOAD inside CLASS ... ENDCLASS.
            me-&gt;insert_cload(
              EXPORTING
                state_pos = state_rec-from
              CHANGING
                cload_tab = vseo_tabs-cload_tab ).
          ENDIF.
*       CLASS x DEFINITION LOCAL FRIENDS ....
        ELSEIF state_len &gt; 5 AND token_re1-str = &apos;LOCAL&apos;.
          x1 = x1 + 2.
          me-&gt;insert_frnds(
            EXPORTING
              clsname   = token_re2-str
              state_pos = x1
              state_end = state_rec-to
            CHANGING
              frnds_tab = vseo_tabs-frnds_tab ).
*       CLASS x DEFINITION ....
        ELSE.
*         initial global structure
          me_priv-superclsname = &apos;*** void ***&apos;. &quot; for interfaces invalid
*         build and insert new record for class
          me-&gt;insert_class(
            EXPORTING
              state_begin = state_rec-from
              state_end   = state_rec-to
            CHANGING
              class_tab   = vseo_tabs-class_tab
              exted_tab   = vseo_tabs-exted_tab
              frnds_tab   = vseo_tabs-frnds_tab ).
*         increase the nested scope
          me_priv-nested_sc    = me_priv-nested_sc + 1.
          me_priv-clsname      = token_re2-str.
          me_priv-is_interface = &apos; &apos;.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-is_interface = me_priv-is_interface.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
*         initial global structure
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
        ENDIF.
*     look for INTERFACE X ... statement
      ELSEIF token_re1-str = &apos;INTERFACE&apos;.
*       INTEFACE x [PUBLIC]. (just in case for an already global interface)
        IF state_len = 2 OR token_re3-str = &apos;PUBLIC&apos;.
*         build and insert new record for interface
          me-&gt;insert_inter(
            EXPORTING
              state_pos = state_rec-from
            CHANGING
              inter_tab = vseo_tabs-inter_tab ).
*         increase the nested scope
          me_priv-nested_sc    = me_priv-nested_sc + 1.
          me_priv-clsname      = token_re2-str.
          me_priv-superclsname = &apos;*** void ***&apos;. &quot; for interfaces invalid
          me_priv-is_interface = &apos;X&apos;.
          me_priv-editor_order = 1.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-is_interface = me_priv-is_interface.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
*       INTERFACE x LOAD inside
        ELSEIF state_len = 3 AND token_re3-str = &apos;LOAD&apos; AND
               me_priv-nested_sc &gt; 0.
          me-&gt;insert_iload(
            EXPORTING
              state_pos = state_rec-from
            CHANGING
              iload_tab = vseo_tabs-iload_tab ).
        ENDIF.
*     look for ENDCLASS or ENDINTERFACE statement
      ELSEIF ( state_len = 1 ) AND
             ( ( token_re1-str = &apos;ENDCLASS&apos; ) OR
               ( token_re1-str = &apos;ENDINTERFACE&apos; ) ).
*       decrease the nested scope
        IF me_priv-nested_sc &gt; 0.
          READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
          me_priv-exposure = scope_rec-exposure.
          DELETE me_priv-scope_sta INDEX 1.
          IF me_priv-nested_sc = 1.
            me_priv-nested_sc    = 0.
            me_priv-clsname      = &apos;*** void ***&apos;.
            me_priv-superclsname = &apos;*** void ***&apos;.
            me_priv-is_interface = &apos; &apos;.
          ELSE.
            me_priv-nested_sc = me_priv-nested_sc - 1.
            READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
            me_priv-clsname      = scope_rec-clsname.
            me_priv-superclsname = scope_rec-superclsname.
            me_priv-is_interface = scope_rec-is_interface.
          ENDIF.
        ENDIF.
*     TYPE-POOLS x.
      ELSEIF state_len = 2 AND token_re1-str = &apos;TYPE-POOLS&apos;.
        me-&gt;insert_tpool(
          EXPORTING
            state_pos = state_rec-from
          CHANGING
            tpool_tab = vseo_tabs-tpool_tab ).
*     look whether we are already inside definition
      ELSEIF me_priv-nested_sc &gt; 0.
        CASE token_re1-str.
*         find token PUBLIC
          WHEN &apos;PUBLIC&apos;.
*         find PUBLIC SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-public.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PROTECTED
          WHEN &apos;PROTECTED&apos;.
*         find PROTECTED SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-protected.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PACKAGE
          WHEN &apos;PACKAGE&apos;.
*         find PACKAGE SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-package.
              me_priv-editor_order = 1.
            ENDIF.
*         find token PRIVATE
          WHEN &apos;PRIVATE&apos;.
*         find PRIVATE SECTION statement
            IF ( state_len = 2 ) AND ( token_re2-str = &apos;SECTION&apos; ).
              me_priv-exposure     = const-exposure-private.
              me_priv-editor_order = 1.
            ENDIF.
*         find constants
          WHEN &apos;CONSTANTS&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 2
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find attributes
          WHEN &apos;DATA&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 0
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find class attributes
          WHEN &apos;CLASS-DATA&apos;.
            me-&gt;insert_attri(
              EXPORTING
                attdecltyp  = 1
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                attri_tab   = vseo_tabs-attri_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find methods
          WHEN &apos;METHODS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_metho(
              EXPORTING
                mtddecltyp = 0
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                metho_tab  = vseo_tabs-metho_tab
                redef_tab  = vseo_tabs-redef_tab
                mpara_tab  = vseo_tabs-mpara_tab
                mexce_tab  = vseo_tabs-mexce_tab ).
*         find class methods
          WHEN &apos;CLASS-METHODS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_metho(
              EXPORTING
                mtddecltyp = 1
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                metho_tab  = vseo_tabs-metho_tab
                redef_tab  = vseo_tabs-redef_tab
                mpara_tab  = vseo_tabs-mpara_tab
                mexce_tab  = vseo_tabs-mexce_tab ).
*         find events
          WHEN &apos;EVENTS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_event(
              EXPORTING
                evtdecltyp = 0
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                event_tab  = vseo_tabs-event_tab
                epara_tab  = vseo_tabs-epara_tab ).
*         find class events
          WHEN &apos;CLASS-EVENTS&apos;.
            CALL FUNCTION &apos;RS_QUALIFY_ABAP_TOKENS_STR&apos;
              EXPORTING
                statement_type = state_rec-type
                index_from     = state_rec-from
                index_to       = state_rec-to
              CHANGING
                stokesx_tab    = me_priv-token_tab.
            me-&gt;insert_event(
              EXPORTING
                evtdecltyp = 1
                state_pos  = state_rec-from
                state_end  = state_rec-to
              CHANGING
                event_tab  = vseo_tabs-event_tab
                epara_tab  = vseo_tabs-epara_tab ).
*         find interfaces (impl.)
          WHEN &apos;INTERFACES&apos;.
            IF me_priv-is_interface = &apos;X&apos;.
              me-&gt;insert_iincl(
                EXPORTING
                  state_pos = state_rec-from
                CHANGING
                  iincl_tab = vseo_tabs-iincl_tab ).
            ELSE.
              me-&gt;insert_iimpl(
                EXPORTING
                  state_pos = state_rec-from
                  state_end = state_rec-to
                CHANGING
                  iimpl_tab = vseo_tabs-iimpl_tab
                  redef_tab = vseo_tabs-redef_tab ).
            ENDIF.
*         find type definition
          WHEN &apos;TYPES&apos;.
            me-&gt;insert_types(
              EXPORTING
                state_begin = state_rec-from
                state_end   = state_rec-to
              CHANGING
                types_tab   = vseo_tabs-types_tab
                typsr_tab   = vseo_tabs-typsr_tab ).
*         find alias definition
          WHEN &apos;ALIASES&apos;.
            me-&gt;insert_alias(
              EXPORTING
                state_pos = state_rec-from
                state_end = state_rec-to
              CHANGING
                alias_tab = vseo_tabs-alias_tab ).
*         find INCLUDE /TYPE/STRUCTURE
          WHEN &apos;INCLUDE&apos;.
*           ignor only inside BEGIN OF ... END OF ...
            IF me_priv-inside_begin_end = 0.
*              RAISE RESUMABLE EXCEPTION TYPE statement_illegal.
            ENDIF.
          WHEN OTHERS.
*           syntax error or unsupported feature
*            RAISE RESUMABLE EXCEPTION TYPE statement_illegal.
        ENDCASE.
      ENDIF.
    ENDLOOP.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE_FOR_METHOD_IMPLS" VERSION="1" LANGU="E" DESCRIPT="SCAN_SOURCE_FOR_METHOD_IMPLS" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SCAN_SOURCE_FOR_METHOD_IMPLS" SCONAME="METHOD_IMPLS" VERSION="1" LANGU="E" DESCRIPT="METHOD_IMPLS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="SABOO_METHOD_IMPL_TAB"/>
   <source>method SCAN_SOURCE_FOR_METHOD_IMPLS.
*  importing source_tab  type saboo_sourt
*  changing  method_impls type saboo_method_impl_tab.

    DATA:
      token_re1            TYPE saboo_tokesx,
      token_re2            TYPE saboo_tokesx,
      token_re3            TYPE saboo_tokesx,
      state_rec            TYPE saboo_state,
      state_len            TYPE i,
      x1                   TYPE i,
      scope_rec            TYPE scope_rec_type,
      begin_row            TYPE i,
      begin_col            TYPE i,
      end_row              TYPE i,
      end_col              TYPE i,
      whole_lines_begin    TYPE i,
      whole_lines_end      TYPE i,
      source_line1         TYPE LINE OF saboo_sourt,
      source_line2         TYPE LINE OF saboo_sourt,
      method_impl          TYPE saboo_method_impl.

    me-&gt;reset( ).

*   main loop to fill all method implementation table
    LOOP AT me_priv-state_tab INTO state_rec.
*     no empty statements
      CHECK state_rec-from &lt;= state_rec-to.
*     look only at normal ABAP statements
      IF ( state_rec-type = &apos;K&apos; ).
        state_len = state_rec-to - state_rec-from + 1.
*       get the first three tokens, if available
        CLEAR: token_re1, token_re2, token_re3.
        x1 = state_rec-from.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        x1 = x1 + 1.
        READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*       look for CLASS X IMPLEMENTATION statement
        IF ( state_len = 3 ) AND ( token_re1-str = &apos;CLASS&apos; ) AND
           ( token_re3-str = &apos;IMPLEMENTATION&apos; ).
*         increase the nested scope
          me_priv-nested_sc = me_priv-nested_sc + 1.
          me_priv-clsname       = token_re2-str.
          me_priv-superclsname  = &apos;*** void ***&apos;.
          scope_rec-clsname      = me_priv-clsname.
          scope_rec-superclsname = me_priv-superclsname.
          scope_rec-exposure     = me_priv-exposure.
          INSERT scope_rec INTO me_priv-scope_sta INDEX 1.
          me_priv-exposure = 2. &quot; default inside new definition PUBLIC
*       look for ENDCLASS
        ELSEIF ( state_len = 1 ) AND ( token_re1-str = &apos;ENDCLASS&apos; ).
*         decrease the nested scope
          IF me_priv-nested_sc &gt; 0.
            READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
            me_priv-exposure = scope_rec-exposure.
            DELETE me_priv-scope_sta INDEX 1.
            IF me_priv-nested_sc = 1.
              me_priv-nested_sc = 0.
              me_priv-clsname      = &apos;*** void ***&apos;.
              me_priv-superclsname = &apos;*** void ***&apos;.
            ELSE.
              SUBTRACT 1 FROM me_priv-nested_sc.
              READ TABLE me_priv-scope_sta INDEX 1 INTO scope_rec.
              me_priv-clsname      = scope_rec-clsname.
              me_priv-superclsname = scope_rec-superclsname.
            ENDIF.
          ENDIF.
*       look whether we are already inside definition
        ELSEIF me_priv-nested_sc &gt; 0.

*         find token ENDMETHOD or METHOD with misssing ENDMETHOD
          IF &apos;ENDMETHOD&apos; = token_re1-str OR
             ( &apos;METHOD&apos; = token_re1-str AND me_priv-cmpname  &lt;&gt; &apos;*** void ***&apos; ).
*           find ENDMETHOD statement
*           calculate end point in source and count whole lines
            end_row = token_re1-row.
            end_col = token_re1-col.
            whole_lines_begin = begin_row + 1.
            whole_lines_end    = end_row - 1.
*           fill wa for p_method_impls
            CLEAR: method_impl.
            method_impl-mtdkey-clsname = me_priv-clsname.
            method_impl-mtdkey-cpdname = me_priv-cmpname.
*           method source not empty ?
            IF ( begin_row &lt;&gt; end_row ) OR ( begin_col &lt;&gt; end_col ).
*             method source in one line ?
              IF ( begin_row = end_row ).
*               append one line
                x1 = end_col - begin_col.
                IF x1 &gt; 0.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX begin_row.
                  source_line2 = source_line1+begin_col(x1).
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
*             method source in more than one line
              ELSE.
*               append first line
                IF begin_col &lt; const-max_line_size.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX begin_row.
                  source_line2 = source_line1+begin_col.
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
*               append whole lines
                IF whole_lines_begin &lt;= whole_lines_end.
                  APPEND LINES OF me_priv-sourc_tab
                    FROM whole_lines_begin TO whole_lines_end
                    TO method_impl-implementation.
                ENDIF.
*               append last line
                IF end_col &gt; 0.
                  READ TABLE me_priv-sourc_tab INTO source_line1 INDEX end_row.
                  source_line2 = source_line1+0(end_col).
                  APPEND source_line2 TO method_impl-implementation.
                ENDIF.
              ENDIF.
            ENDIF.
*           append method to result
            APPEND method_impl TO method_impls.
*           reset indicator
            CLEAR: begin_row, end_row, begin_col, end_col.
            me_priv-cmpname  = &apos;*** void ***&apos;.
          ENDIF.

*         find token METHOD
          IF &apos;METHOD&apos; = token_re1-str.
*           find METHOD &apos;name&apos; statement
*           get method name and calculate start point in source
            me_priv-cmpname = token_re2-str.
            begin_row = state_rec-trow.
            begin_col = state_rec-tcol + 1.
          ENDIF.

        ENDIF.
      ENDIF.
    ENDLOOP.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" VERSION="1" LANGU="E" DESCRIPT="SOURCE_TAB_TO_CHAR" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" SCONAME="TYPSR_REC" VERSION="1" LANGU="E" DESCRIPT="TYPSR_REC" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_TYPSR"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="SOURCE_TAB_TO_CHAR" SCONAME="CHAR" VERSION="1" LANGU="E" DESCRIPT="CHAR" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="C"/>
   <source>method SOURCE_TAB_TO_CHAR.
* importing typsr_rec type saboo_typsr changing char type c.

    DATA:
      len TYPE i,
      from_line TYPE i,
      to_line   TYPE i.

    FIELD-SYMBOLS:
      &lt;line&gt; TYPE c.

    ASSERT typsr_rec-begin_row &lt;= typsr_rec-end_row.

    IF typsr_rec-begin_row = typsr_rec-end_row.
      READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-end_row.
      ASSERT sy-subrc IS INITIAL.
      len = typsr_rec-end_col - typsr_rec-begin_col + 1.
      CONCATENATE char &lt;line&gt;+typsr_rec-begin_col(len) cl_abap_char_utilities=&gt;cr_lf INTO char.
    ELSE.
      READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-begin_row.
      ASSERT sy-subrc IS INITIAL.
      CONCATENATE &lt;line&gt;+typsr_rec-begin_col(*) cl_abap_char_utilities=&gt;cr_lf INTO char.

      from_line = typsr_rec-begin_row + 1.
      to_line   = typsr_rec-end_row - 1.
      LOOP AT me_priv-sourc_tab ASSIGNING &lt;line&gt; FROM from_line TO to_line.
        CONCATENATE char &lt;line&gt; cl_abap_char_utilities=&gt;cr_lf INTO char.
      ENDLOOP.

      IF typsr_rec-begin_row &lt; typsr_rec-end_row.
        READ TABLE me_priv-sourc_tab ASSIGNING &lt;line&gt; INDEX typsr_rec-end_row.
        ASSERT sy-subrc IS INITIAL.
        len = typsr_rec-end_col + 1.
        CONCATENATE char &lt;line&gt;(len) cl_abap_char_utilities=&gt;cr_lf INTO char.
      ENDIF.
    ENDIF.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" VERSION="1" LANGU="E" DESCRIPT="WRITE_EPARA" EXPOSURE="0" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="PARDECLTYP" VERSION="1" LANGU="E" DESCRIPT="PARDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_EPARA" SCONAME="EPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="EPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_EPART"/>
   <source>method WRITE_EPARA.
*   importing value(pardecltyp) type n
*             state_end          type i
*   changing  curre_pos          type i
*             epara_tab          type saboo_epart.
    DATA:
      epara_rec   TYPE saboo_epara,
      token_re1   TYPE saboo_tokesx,
      token_re2   TYPE saboo_tokesx,
      token_re3   TYPE saboo_tokesx,
      x1          TYPE i,
      list_end    TYPE c,
      string1     TYPE string,
      string2     TYPE string.

    DO.
      x1 = curre_pos + 2.
*   do we have enough tokens left for a parameter
      IF x1 &gt; state_end.
        EXIT.
      ENDIF.
      CLEAR: token_re1, token_re2, token_re3, epara_rec, list_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
      x1 = curre_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? stop token, because of ABAP syntax check
      CASE token_re1-str.
        WHEN &apos;EXPORTING&apos;.
          IF pardecltyp &lt; 1.
            list_end = &apos;X&apos;.
          ENDIF.
      ENDCASE.
*   stop word =&gt; next parameter section
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   got the name of the parameter
      CLEAR: string1, string2.
      SPLIT token_re1-str AT &apos;(&apos; INTO string1 string2.
      IF string2 = &apos;&apos;.
*     default is call by value
        epara_rec-sconame    = string1.
*      epara_rec-parpasstyp = 0.
      ELSE.
        CASE string1.
*       ? call by value
          WHEN &apos;VALUE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 0.
*       ? call by reference (but until now only call by value is valid)
          WHEN &apos;REFERENCE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 1.
*       unknown =&gt; default call by value
          WHEN OTHERS.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            epara_rec-sconame    = string1.
*          epara_rec-parpasstyp = 0.
        ENDCASE.
      ENDIF.
*   set type of parameter (e.g. IMPORTING, EXPORTING ...)
*   epara_rec-pardecltyp = pardecltyp. &quot; until now only EXPORTING
*   look for type
      CASE token_re2-str.
*     ? x LIKE y
        WHEN &apos;LIKE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x LIKE REF TO y ... (using LIKE and concatenate REF TO to type)
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              epara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x LIKE LINE OF y ... (using LIKE and concatenate LINE OF to type)
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              epara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            epara_rec-typtype = 0.
            epara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     ? x TYPE ...
        WHEN &apos;TYPE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x TYPE REF TO y ...
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              epara_rec-typtype = 3.
              epara_rec-type    = token_re3-str.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ...
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              epara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE ANY/STANDARD/HASHED/INEX/SOETED TABLE
            ELSEIF ( ( token_re1-str = &apos;ANY&apos; )      OR
                     ( token_re1-str = &apos;STANDARD&apos; ) OR
                     ( token_re1-str = &apos;HASHED&apos; )   OR
                     ( token_re1-str = &apos;INDEX&apos; )    OR
                     ( token_re1-str = &apos;SORTED&apos; ) ) AND
                   ( token_re2-str = &apos;TABLE&apos; ).
              epara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str
                INTO epara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 4.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            epara_rec-typtype = 1.
            epara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     no type
        WHEN OTHERS.
          list_end = &apos;X&apos;.
      ENDCASE.
*   no type =&gt; no parameter
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   defaults for addition data
      epara_rec-paroptionl = &apos; &apos;.
      epara_rec-parvalue   = &apos;&apos;.
*   look for additions
      IF curre_pos &lt;= state_end.
        CLEAR: token_re1, token_re2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
        x1 = curre_pos + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
        CASE token_re1-str.
*       ? OPTIONAL
          WHEN &apos;OPTIONAL&apos;.
            epara_rec-paroptionl = &apos;X&apos;.
            curre_pos = curre_pos + 1.
*       ? DEFAULT
          WHEN &apos;DEFAULT&apos;.
            epara_rec-paroptionl = &apos; &apos;.           &quot;MS 20070423
            epara_rec-parvalue   = token_re2-str.
            curre_pos            = curre_pos + 2.
        ENDCASE.
      ENDIF.
*   fill global record and append it
      epara_rec-clsname    = me_priv-clsname.
      epara_rec-cmpname    = me_priv-cmpname.
      epara_rec-version    = me_priv-version.
      epara_rec-langu      = me_priv-langu.
      epara_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
      APPEND epara_rec TO epara_tab.
    ENDDO.
endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" VERSION="1" LANGU="E" DESCRIPT="WRITE_MPARA" EXPOSURE="0" STATE="1" EDITORDER="20 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="PARDECLTYP" VERSION="1" LANGU="E" DESCRIPT="PARDECLTYP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="N"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="STATE_END" VERSION="1" LANGU="E" DESCRIPT="STATE_END" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="CURRE_POS" VERSION="1" LANGU="E" DESCRIPT="CURRE_POS" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
   <parameter CLSNAME="ZCL_WB_SCANNER_OBJECTS" CMPNAME="WRITE_MPARA" SCONAME="MPARA_TAB" VERSION="1" LANGU="E" DESCRIPT="MPARA_TAB" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_MPART"/>
   <source>method WRITE_MPARA.
*   importing value(pardecltyp) type n
*             state_end         type i
*   changing  curre_pos         type i
*             mpara_tab         type saboo_mpart.

    DATA:
      mpara_rec   TYPE saboo_mpara,
      token_re1   TYPE saboo_tokesx,
      token_re2   TYPE saboo_tokesx,
      token_re3   TYPE saboo_tokesx,
      x1          TYPE i,
      list_end    TYPE c,
      string1(30) TYPE c,
      string2(30) TYPE c.

    FIELD-SYMBOLS:
      &lt;fs&gt; TYPE saboo_mpara.

    DO.
      x1 = curre_pos + 2.
*   do we have enough tokens left for a parameter
      IF x1 &gt; state_end.
        EXIT.
      ENDIF.
      CLEAR: token_re1, token_re2, token_re3, mpara_rec, list_end.
      READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
      x1 = curre_pos + 1.
      READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
      x1 = curre_pos + 2.
      READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
*   ? stop token, because of ABAP syntax check
      CASE token_re1-str.
        WHEN &apos;EXPORTING&apos;.
          IF pardecltyp &lt; 1.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;CHANGING&apos;.
          IF pardecltyp &lt; 2.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;RETURNING&apos;.
          IF pardecltyp &lt; 3.
            list_end = &apos;X&apos;.
          ENDIF.
        WHEN &apos;PREFERRED&apos;.
*       addition PREFERRED PARAMETER x for importing parameter
          IF token_re2-str = &apos;PARAMETER&apos; AND pardecltyp = 0.
            READ TABLE mpara_tab                            &quot;#EC *
              ASSIGNING &lt;fs&gt;
              WITH KEY clsname = me_priv-clsname
                       cmpname = me_priv-cmpname(30)
                       sconame = token_re3-str. &quot;EC *
            IF sy-subrc = 0.
              &lt;fs&gt;-parpreferd = &apos;X&apos;.
            ENDIF.
            curre_pos = curre_pos + 3.
            list_end = &apos;X&apos;.
          ENDIF.
      ENDCASE.
*   stop word =&gt; next parameter section
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   got the name of the parameter
      CLEAR: string1, string2.
      SPLIT token_re1-str AT &apos;(&apos; INTO string1 string2.
      IF string2 = &apos;&apos;.
*     default is call by reference
        mpara_rec-sconame    = string1.
        mpara_rec-parpasstyp = 1.
      ELSE.
        CASE string1.
*       ? call by value
          WHEN &apos;VALUE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 0.
*       ? call by reference
          WHEN &apos;REFERENCE&apos;.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 1.
*       unknown =&gt; default call by reference
          WHEN OTHERS.
            SPLIT string2 AT &apos;)&apos; INTO string1 string2.
            mpara_rec-sconame    = string1.
            mpara_rec-parpasstyp = 0.
        ENDCASE.
      ENDIF.
*   set type of parameter (e.g. IMPORTING, EXPORTING ...)
      mpara_rec-pardecltyp = pardecltyp.
*   look for type
      CASE token_re2-str.
*     ? x LIKE y
        WHEN &apos;LIKE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x LIKE REF TO y ... (using LIKE and concatenate REF TO to type)
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              mpara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ... (using LIKE and concatenate LINE OF to type)
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              mpara_rec-typtype = 0.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            mpara_rec-typtype = 0.
            mpara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     ? x TYPE ...
        WHEN &apos;TYPE&apos;.
          CLEAR: token_re1, token_re2, token_re3.
          x1 = curre_pos + 2.
          IF ( x1 &lt;= state_end ).
            READ TABLE me_priv-token_tab INTO token_re1 INDEX x1.
            x1 = curre_pos + 3.
            IF ( x1 &lt;= state_end ).
              READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
              x1 = curre_pos + 4.
              IF ( x1 &lt;= state_end ).
                READ TABLE me_priv-token_tab INTO token_re3 INDEX x1.
              ENDIF.
            ENDIF.
          ENDIF.
          IF token_re1-type = sana_tok_word AND token_re2-type = sana_tok_word.
*       ? x TYPE REF TO y ...
            IF ( token_re1-str = &apos;REF&apos; ) AND ( token_re2-str = &apos;TO&apos; ).
              mpara_rec-typtype = 3.
              mpara_rec-type    = token_re3-str.
              curre_pos = curre_pos + 5.
*       ? x TYPE LINE OF y ...
            ELSEIF ( token_re1-str = &apos;LINE&apos; ) AND ( token_re2-str = &apos;OF&apos; ).
              mpara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str token_re3-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 5.
*       ? x TYPE ANY/STANDARD/HASHED/INEX/SOETED TABLE
            ELSEIF ( ( token_re1-str = &apos;ANY&apos; )      OR
                     ( token_re1-str = &apos;STANDARD&apos; ) OR
                     ( token_re1-str = &apos;HASHED&apos; )   OR
                     ( token_re1-str = &apos;INDEX&apos; )    OR
                     ( token_re1-str = &apos;SORTED&apos; ) ) AND
                   ( token_re2-str = &apos;TABLE&apos; ).
              mpara_rec-typtype = 1.
              CONCATENATE token_re1-str token_re2-str
                INTO mpara_rec-type SEPARATED BY space.
              curre_pos = curre_pos + 4.
            ELSE.
*           some unknown token string
              &quot;raise exception type statement_illegal.
            ENDIF.
*       ? x type y ...
          ELSE.
            mpara_rec-typtype = 1.
            mpara_rec-type    = token_re1-str.
            curre_pos         = curre_pos + 3.
          ENDIF.
*     no type
        WHEN OTHERS.
          list_end = &apos;X&apos;.
      ENDCASE.
*   no type =&gt; no parameter
      IF list_end = &apos;X&apos;.
        EXIT.
      ENDIF.
*   defaults for addition data
      mpara_rec-paroptionl = &apos; &apos;.
      mpara_rec-parvalue   = &apos;&apos;.
*   look for additions
      IF curre_pos &lt;= state_end.
        CLEAR: token_re1, token_re2.
        READ TABLE me_priv-token_tab INTO token_re1 INDEX curre_pos.
        x1 = curre_pos + 1.
        READ TABLE me_priv-token_tab INTO token_re2 INDEX x1.
*     only if token is word and not identifier
        IF token_re1-type = sana_tok_word.
          CASE token_re1-str.
*       ? OPTIONAL
            WHEN &apos;OPTIONAL&apos;.
              mpara_rec-paroptionl = &apos;X&apos;.
              curre_pos            = curre_pos + 1.
*       ? DEFAULT
            WHEN &apos;DEFAULT&apos;.
              mpara_rec-paroptionl = &apos; &apos;.           &quot;MS 20070423
              mpara_rec-parvalue   = token_re2-str.
              curre_pos            = curre_pos + 2.
          ENDCASE.
        ENDIF.
      ENDIF.
*   fill global record and append it
      mpara_rec-clsname    = me_priv-clsname.
      mpara_rec-cmpname    = me_priv-cmpname.
      mpara_rec-version    = me_priv-version.
      mpara_rec-langu      = me_priv-langu.
      mpara_rec-mtdtype    = me_priv-mtdtype.
      mpara_rec-editorder  = me_priv-editor_order. ADD 1 TO me_priv-editor_order.
      APPEND mpara_rec TO mpara_tab.
    ENDDO.
endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE_LOCAL" VERSION="1" LANGU="E" DESCRIPT="Local Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_INTERFACE">
  <implementing CLSNAME="ZCL_WB_INTERFACE_LOCAL" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOK" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE_LOCAL" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SABOO</forwardDeclaration>
  <forwardDeclaration>SEOK</forwardDeclaration>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <forwardDeclaration>SEOR</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <forwardDeclaration>SEOT</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="INTERF_NAME" VERSION="1" LANGU="E" DESCRIPT="Object Type Name" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOINTERF-CLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAMM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_INTERFACE_LOCAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" STATE="1"/>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_INTERFACE_NAME" VERSION="1" LANGU="E" DESCRIPT="Object Type Name" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOINTERF-CLSNAME"/>
   <source>method CONSTRUCTOR.
super-&gt;constructor( ).
me-&gt;program = im_program.
me-&gt;interf_name = im_interface_name.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="LOAD_ALL_INTERFACES" SCONAME="RE_T_R_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="Table of WB local interfaces" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTT_WB_INTERFACE_LOCAL"/>
   <source>METHOD load_all_interfaces.

  DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
  DATA t_source_code TYPE saboo_sourt.
  DATA lwa_vseo_tabs TYPE saboo_vseot .
  DATA lwa_interface LIKE LINE OF lwa_vseo_tabs-inter_tab.

  READ REPORT im_program INTO t_source_code.
  zcl_wb_scanner_objects=&gt;create(
    IMPORTING
      scanner = r_wb_scanner
    CHANGING
      sourc_tab = t_source_code  ).

  lwa_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

  DATA lr_local_interface TYPE REF TO zcl_wb_interface_local.
  LOOP AT lwa_vseo_tabs-inter_tab INTO lwa_interface.

    CREATE OBJECT lr_local_interface
      EXPORTING
        im_program        = im_program
        im_interface_name = lwa_interface-clsname.

    lr_local_interface-&gt;move_vseo_tabs_to_att( im_vseo_tabs = lwa_vseo_tabs ).

    APPEND lr_local_interface TO re_t_r_interfaces.

  ENDLOOP.
ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" SCONAME="IM_VSEO_TABS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>method MOVE_VSEO_TABS_TO_ATT.

* Class
    data lwa_vseointerf type vseointerf.
    loop at im_vseo_tabs-inter_tab into lwa_vseointerf
        where clsname = me-&gt;interf_name.
      me-&gt;INTERFACE = lwa_vseointerf.
    endloop.

* Attributes
    data lwa_vseoattrib type vseoattrib.
    loop at im_vseo_tabs-attri_tab into lwa_vseoattrib
      where clsname = me-&gt;interf_name.
      append lwa_vseoattrib to me-&gt;attributes.
    endloop.

* Methods
    data lwa_vseomethod type vseomethod.
    loop at im_vseo_tabs-metho_tab into lwa_vseomethod
      where clsname = me-&gt;interf_name.
      append lwa_vseomethod to me-&gt;methods.
    endloop.

* Method parameters
*    DATA lwa_mpara_tab TYPE vseomepara.
*    LOOP AT im_vseo_tabs-mpara_tab INTO lwa_mpara_tab
*      WHERE clsname = me-&gt;class_name.
*      APPEND lwa_mpara_tab TO me-&gt;parameters.
*    ENDLOOP.

* Exceptions
    data lwa_mexce_tab type vseoexcep.
    loop at im_vseo_tabs-mexce_tab into lwa_mexce_tab
      where clsname = me-&gt;interf_name.
      append lwa_mexce_tab to me-&gt;exceps.
    endloop.

* Interfaces
*    data lwa_vseoimplem type vseoimplem.
*    loop at im_vseo_tabs-iimpl_tab into lwa_vseoimplem
*      where clsname = me-&gt;interf_name.
*      append lwa_vseoimplem to me-&gt;implementings.
*    endloop.

* Types
    data lwa_vseotype type vseotype.
    loop at im_vseo_tabs-types_tab into lwa_vseotype
      where clsname = me-&gt;interf_name.
      append lwa_vseotype to me-&gt;types.
    endloop.



endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE_GLOBAL" VERSION="1" LANGU="E" DESCRIPT="WB global interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_INTERFACE">
  <implementing CLSNAME="ZCL_WB_INTERFACE_GLOBAL" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="ENHA_ACTION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="IGNORE_SWITCHES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="INTKEY" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSKEY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="READ_ACTIVE_ENHA" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="VERSION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOVERSION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="WITH_ENHANCEMENTS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_INTERFACE_GLOBAL" REFCLSNAME="ZCL_WB_INTERFACE" VERSION="1" STATE="1"/>
  <interfaceMethod CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>method ZIF_WB_OBJECT~LOAD.

    CALL FUNCTION &apos;SEO_INTERFACE_TYPEINFO_GET&apos;
      EXPORTING
        intkey                  = me-&gt;intkey
        version                 = me-&gt;version
        state                   = me-&gt;state
        with_master_language    = me-&gt;with_master_language
        with_enhancements       = me-&gt;with_enhancements
        read_active_enha        = me-&gt;read_active_enha
        enha_action             = me-&gt;enha_action
        ignore_switches         = me-&gt;ignore_switches
      IMPORTING
        interface               = me-&gt;interface
        attributes              = me-&gt;attributes
        methods                 = me-&gt;methods
        events                  = me-&gt;events
        parameters              = me-&gt;parameters
        exceps                  = me-&gt;exceps
        comprisings             = me-&gt;comprisings
        typepusages             = me-&gt;typepusages
        clsdeferrds             = me-&gt;clsdeferrds
        intdeferrds             = me-&gt;intdeferrds
        explore_comprisings     = me-&gt;explore_comprisings
        aliases                 = me-&gt;aliases
        types                   = me-&gt;types
        enhancement_methods     = me-&gt;enhancement_methods
        enhancement_attributes  = me-&gt;enhancement_attributes
        enhancement_events      = me-&gt;enhancement_events
        enhancement_comprisings = me-&gt;enhancement_comprisings
        enhancement_types       = me-&gt;enhancement_types
      EXCEPTIONS
        not_existing            = 1
        is_class                = 2
        model_only              = 3
        OTHERS                  = 4.
    IF sy-subrc &lt;&gt; 0.
* Implement suitable error handling here
    ENDIF.

endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_INTKEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSKEY"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOVERSION" PARVALUE="SEOC_VERSION_INACTIVE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOSTATE" PARVALUE="&apos;1&apos;"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_ENHANCEMENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_READ_ACTIVE_ENHA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_ENHA_ACTION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_INTERFACE_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_IGNORE_SWITCHES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR1" PARVALUE="&apos;X&apos;"/>
   <source>method CONSTRUCTOR.

  super-&gt;constructor( ).

    me-&gt;intkey                = im_intkey.
    me-&gt;version               = im_version.
    me-&gt;state                 = im_state.
    me-&gt;with_master_language  = im_with_master_language.
    me-&gt;with_enhancements     = im_with_enhancements.
    me-&gt;read_active_enha      = im_read_active_enha.
    me-&gt;enha_action           = im_enha_action.
    me-&gt;ignore_switches       = im_ignore_switches.

endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Generic Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOK" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_WB_INTERFACE" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SEOK</forwardDeclaration>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <forwardDeclaration>SEOR</forwardDeclaration>
  <forwardDeclaration>SEOS</forwardDeclaration>
  <forwardDeclaration>SEOT</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ALIASES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ALIASES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ATTRIBUTES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="CLSDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_CLSDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="COMPRISINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_COMPRISINGS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_ATTRIBUTES" VERSION="1" LANGU="E" DESCRIPT="Table with attributes that were defined as enhancements" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABATTRIB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_COMPRISINGS" VERSION="1" LANGU="E" DESCRIPT="Table with interfaces defines in interfaces as enhancement" EXPOSURE="2" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABINTFCOMPRI" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_EVENTS" VERSION="1" LANGU="E" DESCRIPT="Table with events that were defined as enhancements" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABEVENT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_METHODS" VERSION="1" LANGU="E" DESCRIPT="Table with header data from new enhancement methods" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHMETH_TABHEADER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="ENHANCEMENT_TYPES" VERSION="1" LANGU="E" DESCRIPT="Table with Types as Enhancements" EXPOSURE="2" STATE="1" EDITORDER="18 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHTYPE_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_EVENTS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EXCEPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_EXCEPTIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="EXPLORE_COMPRISINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_INT_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="INTDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_INTDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Generated Table for View" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOINTERF" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_METHODS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="PARAMETERS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_PARAMETERS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="TYPEPUSAGES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_TYPEPUSAGES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_INTERFACE" CMPNAME="TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_TYPES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZCL_WB_INTERFACE" CMPNAME="TO_STRING" VERSION="1" LANGU="E" DESCRIPT="To String" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD to_string.


  WRITE:
    &apos;Interface:&apos;,
    me-&gt;interface-clsname,
    &apos; - &apos;,
    me-&gt;interface-descript.
  NEW-LINE.

* attributes
  DATA lwa_attributes TYPE vseoattrib.
  WRITE: &apos;Attributes&apos; COLOR 3. NEW-LINE.

  LOOP AT me-&gt;attributes INTO lwa_attributes.
    WRITE lwa_attributes-cmpname        . NEW-LINE.

  ENDLOOP.

  DATA lwa_method TYPE seoo_method_r.
  WRITE: &apos;Methods&apos; COLOR 3. NEW-LINE.
  LOOP AT me-&gt;methods INTO lwa_method.
    WRITE lwa_method-cmpname. NEW-LINE.
  ENDLOOP.
  ULINE.

ENDMETHOD.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS_LOCAL" VERSION="1" LANGU="E" DESCRIPT="Local Class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_CLASS">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>INCLUDE zi_wb_fake_class_local.
  INCLUDE zi_wb_fake_no_classes.
  INCLUDE zi_zcl_wb_class_local_fakes.

  CLASS lcl_wb_class_local_test DEFINITION DEFERRED.
  CLASS zcl_wb_class_local DEFINITION LOCAL FRIENDS lcl_wb_class_local_test.

*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_wb_class_local_test DEFINITION FOR TESTING
    DURATION SHORT
    RISK LEVEL HARMLESS
  .

    PUBLIC SECTION.

* Load tests
      METHODS load_class_loaded FOR TESTING.
      METHODS load_class_dont_exist FOR TESTING.
      METHODS load_class_is_interface FOR TESTING.

* Load_all_classes tests
      METHODS load_all_classes_success FOR TESTING.
      METHODS load_all_classes_no_report FOR TESTING.
      METHODS load_all_classes_no_classes FOR TESTING.

* Move_vseo_tabs_to_att tests
      METHODS move_vseo_tabs_to_att_class FOR TESTING.
*    METHODS move_vseo_tabs_to_att_inter FOR TESTING.
*    METHODS move_vseo_tabs_to_att_attri FOR TESTING.
*    METHODS move_vseo_tabs_to_att_metho FOR TESTING.
*    METHODS move_vseo_tabs_to_att_mpara FOR TESTING.
*    METHODS move_vseo_tabs_to_att_mexce FOR TESTING.
*    METHODS move_vseo_tabs_to_att_event FOR TESTING.
*    METHODS move_vseo_tabs_to_att_epara FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iimpl FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iincl FOR TESTING.
*    METHODS move_vseo_tabs_to_att_typsr FOR TESTING.
*    METHODS move_vseo_tabs_to_att_types FOR TESTING.
*    METHODS move_vseo_tabs_to_att_alias FOR TESTING.
*    METHODS move_vseo_tabs_to_att_redef FOR TESTING.
*    METHODS move_vseo_tabs_to_att_exted FOR TESTING.
*    METHODS move_vseo_tabs_to_att_cload FOR TESTING.
*    METHODS move_vseo_tabs_to_att_iload FOR TESTING.
*    METHODS move_vseo_tabs_to_att_tpool FOR TESTING.
*    METHODS move_vseo_tabs_to_att_frnds FOR TESTING.


    PROTECTED SECTION.
**********************************************************************
*  GIVEN
**********************************************************************

* Local Class setup
      METHODS given_class_is
        IMPORTING
          !im_report_name TYPE reposrc-progname
          !im_class_name TYPE seoclsname .
      METHODS given_class_exist .
      METHODS given_class_dont_exist .
      METHODS given_class_is_interface .

* Report/include setup
      METHODS given_report_is
           IMPORTING
             !im_report_name TYPE reposrc-progname.
      METHODS given_report_exist.
      METHODS given_report_dont_exist.
      METHODS given_report_without_class.

* vseo tabs setup
      METHODS given_vseo_tabs_class_filled.

**********************************************************************
*  WHEN
**********************************************************************
      METHODS when_load.
      METHODS when_load_all_classes.
      METHODS when_move_vseo_tabs_to_att.

**********************************************************************
*  THEN
**********************************************************************
* Exceptions
      METHODS then_exception_raised
        IMPORTING
          !im_class_name TYPE seoclsname.
      METHODS then_no_exception_raised.

      METHODS then_class_loaded.
      METHODS then_class_not_loaded.

      METHODS then_all_classes_loaded.
      METHODS then_no_classes_loaded.

      METHODS then_att_class_filled.

    PRIVATE SECTION.
      METHODS setup.
      METHODS teardown.

      DATA o_wb_local_class TYPE REF TO zcl_wb_class_local.
      DATA o_wb_exception TYPE REF TO zcx_wb_objects .


*--------------------------------------------------------------------*
* Load_all_classes context
      DATA v_report_name TYPE reposrc-progname.
      DATA t_loaded_classes TYPE ztt_wb_class_local.
*--------------------------------------------------------------------*
  ENDCLASS.       &quot;lcl_wb_class_local_test



*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_test IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
  CLASS lcl_wb_class_local_test IMPLEMENTATION.


    METHOD setup.
      CLEAR me-&gt;o_wb_local_class.
      CLEAR me-&gt;o_wb_exception.
    ENDMETHOD.       &quot;setup


    METHOD teardown.

    ENDMETHOD.       &quot;teardown



**********************************************************************
* Methods under test
**********************************************************************
    METHOD load_class_loaded.

      given_class_exist( ).
      when_load( ).
      then_class_loaded( ).
      then_no_exception_raised( ).

    ENDMETHOD.                    &quot;LOAD_CLASS_LOADED


    METHOD load_class_dont_exist.

      given_class_dont_exist( ).
      when_load( ).
      then_class_not_loaded( ).
      then_exception_raised( &apos;ZCX_CLASS_DONT_EXIST&apos; ).

    ENDMETHOD.                    &quot;LOAD_CLASS_DONT_EXIST


    METHOD load_class_is_interface.

      given_class_is_interface( ).
      when_load( ).
      then_class_not_loaded( ).
      then_exception_raised( &apos;ZCX_IS_INTERFACE&apos; ).

    ENDMETHOD.                    &quot;load_class_is_interface


    METHOD load_all_classes_success.

      given_report_exist( ).
      when_load_all_classes( ).
      then_all_classes_loaded( ).
      then_no_exception_raised( ).

    ENDMETHOD.       &quot;load_all_classes_success

    METHOD load_all_classes_no_report.

      given_report_dont_exist( ).
      when_load_all_classes( ).
      then_no_classes_loaded( ).
      then_exception_raised( &apos;ZCX_WB_REPORT_DONT_EXIST&apos; ).

    ENDMETHOD.       &quot;load_all_classes_success


    METHOD load_all_classes_no_classes.

      given_report_without_class( ).
      when_load_all_classes( ).
      then_no_classes_loaded( ).
      then_exception_raised( &apos;ZCX_WB_REPORT_WITHOUT_CLASS&apos; ).

    ENDMETHOD.       &quot;load_all_classes_success




    METHOD move_vseo_tabs_to_att_class.

      given_vseo_tabs_class_filled( ).
      when_move_vseo_tabs_to_att( ).
      then_att_class_filled( ).

    ENDMETHOD.                    &quot;move_vseo_tabs_to_att_class














**********************************************************************
*  GIVEN
**********************************************************************

    METHOD given_class_dont_exist.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;ZCL_NOT_CREATED_CLASS&apos; ).
    ENDMETHOD.                    &quot;given_class_dont_exist


    METHOD given_class_exist.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;LCL_A&apos; ).
    ENDMETHOD.                    &quot;given_class_exist

    METHOD given_class_is.

      CREATE OBJECT me-&gt;o_wb_local_class
        EXPORTING
          im_program    = im_report_name
          im_class_name = im_class_name.

    ENDMETHOD.                    &quot;given_class_is

    METHOD given_class_is_interface.
      given_class_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; im_class_name = &apos;ZIF_WB_FAKE_INTERFACE&apos; ).
    ENDMETHOD.                    &quot;given_class_is_interface

    METHOD given_report_is.
      me-&gt;v_report_name = im_report_name.
    ENDMETHOD.                    &quot;given_report_is

    METHOD given_report_exist.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_CLASS_LOCAL&apos; ).
    ENDMETHOD.                    &quot;given_report_exist

    METHOD given_report_dont_exist.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_NOT_CREATED&apos; ).
    ENDMETHOD.                    &quot;given_report_dont_exist

    METHOD given_report_without_class.
      given_report_is( im_report_name = &apos;ZI_WB_FAKE_NO_CLASSES&apos; ).
    ENDMETHOD.                    &quot;given_report_without_class



    METHOD given_vseo_tabs_class_filled.

      CREATE OBJECT me-&gt;o_wb_local_class
        EXPORTING
          im_program    = space
          im_class_name = lcl_wb_class_local_stub=&gt;create_class_name( ).

      me-&gt;o_wb_local_class-&gt;t_vseo_tabs-class_tab = lcl_wb_class_local_stub=&gt;create_vseo_tabs_class( ).

    ENDMETHOD.                    &quot;given_vseo_tabs_class_filled


**********************************************************************
*  WHEN
**********************************************************************
    METHOD when_load.

      TRY .
          me-&gt;o_wb_local_class-&gt;zif_wb_object~load( ).
        CATCH zcx_wb_objects INTO me-&gt;o_wb_exception.

      ENDTRY.

    ENDMETHOD.                    &quot;when_load

    METHOD when_load_all_classes.

      TRY .
          me-&gt;t_loaded_classes = zcl_wb_class_local=&gt;load_all_classes( im_program = me-&gt;v_report_name ).
        CATCH zcx_wb_report_dont_exist INTO me-&gt;o_wb_exception.       &quot; Report/Include doesn&apos;t exist
        CATCH zcx_wb_report_without_class INTO me-&gt;o_wb_exception.    &quot; Report/Include without classes
      ENDTRY.

    ENDMETHOD.                    &quot;WHEN_LOAD_ALL_CLASSES


    METHOD when_move_vseo_tabs_to_att.

      me-&gt;o_wb_local_class-&gt;move_vseo_tabs_to_att( im_vseo_tabs = me-&gt;o_wb_local_class-&gt;t_vseo_tabs ).

    ENDMETHOD.                    &quot;when_move_vseo_tabs_to_att

**********************************************************************
*  THEN
**********************************************************************
    METHOD then_class_loaded.

      cl_aunit_assert=&gt;assert_not_initial(
        EXPORTING
          act              = me-&gt;o_wb_local_class-&gt;class-clsname    &quot; Actual Data Object
          msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_class_loaded

    METHOD then_class_not_loaded.

      cl_aunit_assert=&gt;assert_initial(
        EXPORTING
          act              = me-&gt;o_wb_local_class-&gt;class-clsname    &quot; Actual Data Object
          msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_class_not_loaded


    METHOD then_exception_raised.

* TODO: how to dynamically assert that a specific exception was thrown?

      cl_aunit_assert=&gt;assert_bound(
        EXPORTING
          act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
      ).

    ENDMETHOD.                    &quot;then_exception_raised


    METHOD then_no_exception_raised.

      cl_aunit_assert=&gt;assert_not_bound(
        EXPORTING
          act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
      ).
    ENDMETHOD.                    &quot;then_no_exception_raised

    METHOD then_all_classes_loaded.

      cl_aunit_assert=&gt;assert_not_initial(
        EXPORTING
          act              = me-&gt;t_loaded_classes    &quot; Actual Data Object
          msg              = &apos;Loaded classes are empty&apos;    &quot; Message in Case of Error
      ).

      DATA lwa_loaded_class LIKE LINE OF me-&gt;t_loaded_classes.
      LOOP AT me-&gt;t_loaded_classes INTO lwa_loaded_class.

        cl_aunit_assert=&gt;assert_not_initial(
          EXPORTING
            act              = lwa_loaded_class-&gt;class-clsname    &quot; Actual Data Object
            msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
        ).

      ENDLOOP.

    ENDMETHOD.                    &quot;then_all_classes_loaded

    METHOD then_no_classes_loaded.

      cl_aunit_assert=&gt;assert_initial(
        EXPORTING
          act              = me-&gt;t_loaded_classes    &quot; Actual Data Object
          msg              = &apos;Loaded classes are empty&apos;    &quot; Message in Case of Error
      ).

    ENDMETHOD.                    &quot;then_no_classes_loaded

    METHOD then_att_class_filled.

      DATA lwa_vseo_tabs TYPE saboo_vseot.

      DATA lwa_att_class TYPE vseoclass.
      lwa_vseo_tabs-class_tab = lcl_wb_class_local_stub=&gt;create_vseo_tabs_class( ).

      READ TABLE lwa_vseo_tabs-class_tab WITH KEY clsname = me-&gt;o_wb_local_class-&gt;class-clsname INTO lwa_att_class.
      IF sy-subrc IS INITIAL.

        cl_aunit_assert=&gt;assert_equals(
          EXPORTING
            exp                  = lwa_att_class    &quot; Data Object with Expected Type
            act                  = me-&gt;o_wb_local_class-&gt;class    &quot; Data Object with Current Value
*    msg                  =     &quot; Message in Case of Error
*    level                = CRITICAL    &quot; Error Severity
*    tol                  =     &quot; Tolerance Range for Floating Point Numbers
*    quit                 = METHOD    &quot; Flow Control in Case of Error
*    ignore_hash_sequence = ABAP_FALSE    &quot; Ignore change sequence in hash tables
*  RECEIVING
*    assertion_failed     =     &quot; Condition not met
        ).

      ENDIF.

    ENDMETHOD.                    &quot;then_att_class_filled

  ENDCLASS.       &quot;lcl_wb_class_local_test</localTestClasses>
  <typeUsage CLSNAME="ZCL_WB_CLASS_LOCAL" TYPEGROUP="SABOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SABOO</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CLASS_NAME" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOCLASS-CLSNAME" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program/Include Name" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="PROGRAMM" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="T_VSEO_TABS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SABOO_VSEOT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_CLASS_LOCAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_CLASS_LOCAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS_LOCAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

  DATA lt_source_code TYPE saboo_sourt.
  DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
  DATA lwa_class LIKE LINE OF me-&gt;t_vseo_tabs-class_tab.

  READ REPORT me-&gt;program INTO lt_source_code.
  zcl_wb_scanner_objects=&gt;create(
    IMPORTING
      scanner = r_wb_scanner
    CHANGING
      sourc_tab = lt_source_code  ).

  me-&gt;t_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

  READ TABLE  me-&gt;t_vseo_tabs-class_tab INTO lwa_class WITH KEY clsname = me-&gt;class_name.
  IF sy-subrc IS INITIAL.
    me-&gt;move_vseo_tabs_to_att(
    EXPORTING
      im_vseo_tabs = me-&gt;t_vseo_tabs
    ).
  ELSE.
    RAISE EXCEPTION TYPE zcx_class_dont_exist.
  ENDIF.

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_CLASS_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="VSEOCLASS-CLSNAME"/>
   <source>method CONSTRUCTOR.
    super-&gt;constructor( ).

    me-&gt;program     = im_program.
    me-&gt;class_name  = im_class_name.

endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" VERSION="1" LANGU="E" DESCRIPT="Load all local classes inside a program/include" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="IM_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="ABAP Program Name" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="PROGRAMM"/>
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="RE_T_R_CLASSES" VERSION="1" LANGU="E" DESCRIPT="Table of WB local classes" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="ZTT_WB_CLASS_LOCAL"/>
   <exception CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="ZCX_WB_REPORT_DONT_EXIST" VERSION="1" LANGU="E" DESCRIPT="Report/Include doesn&apos;t exist" MTDTYPE="0" EDITORDER="1 "/>
   <exception CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="LOAD_ALL_CLASSES" SCONAME="ZCX_WB_REPORT_WITHOUT_CLASS" VERSION="1" LANGU="E" DESCRIPT="Report/Include without classes" MTDTYPE="0" EDITORDER="2 "/>
   <source>METHOD load_all_classes.

  DATA r_wb_scanner TYPE REF TO zcl_wb_scanner_objects.
  DATA t_source_code TYPE saboo_sourt.
  DATA lwa_vseo_tabs TYPE saboo_vseot .
  DATA lwa_class LIKE LINE OF lwa_vseo_tabs-class_tab.

  READ REPORT im_program INTO t_source_code.
  IF sy-subrc IS NOT INITIAL.
    &quot; If the report doesn&apos;t exist or cannot be read, the same exception is thrown
    RAISE EXCEPTION TYPE zcx_wb_report_dont_exist.
  ENDIF.

  zcl_wb_scanner_objects=&gt;create(
    IMPORTING
      scanner = r_wb_scanner
    CHANGING
      sourc_tab = t_source_code  ).

  lwa_vseo_tabs = r_wb_scanner-&gt;scan_source( ).

  DATA lr_local_class TYPE REF TO zcl_wb_class_local.

  IF lwa_vseo_tabs-class_tab IS INITIAL.
    RAISE EXCEPTION TYPE zcx_wb_report_without_class.
  ENDIF.

  LOOP AT lwa_vseo_tabs-class_tab INTO lwa_class.

    CREATE OBJECT lr_local_class
      EXPORTING
        im_program    = im_program
        im_class_name = lwa_class-clsname.

    lr_local_class-&gt;move_vseo_tabs_to_att( im_vseo_tabs = lwa_vseo_tabs ).

    APPEND lr_local_class TO re_t_r_classes.

  ENDLOOP.

ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_LOCAL" CMPNAME="MOVE_VSEO_TABS_TO_ATT" SCONAME="IM_VSEO_TABS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SABOO_VSEOT"/>
   <source>method MOVE_VSEO_TABS_TO_ATT.

* Class
    DATA lwa_vseoclass TYPE vseoclass.
    LOOP AT im_vseo_tabs-class_tab INTO lwa_vseoclass
        WHERE clsname = me-&gt;class_name.
      me-&gt;class = lwa_vseoclass.
    ENDLOOP.

* Attributes
    DATA lwa_vseoattrib TYPE vseoattrib.
    LOOP AT im_vseo_tabs-attri_tab INTO lwa_vseoattrib
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_vseoattrib TO me-&gt;attributes.
    ENDLOOP.

* Methods
    DATA lwa_vseomethod TYPE vseomethod.
    LOOP AT im_vseo_tabs-metho_tab INTO lwa_vseomethod
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_vseomethod TO me-&gt;methods.
    ENDLOOP.

* Method parameters
*    DATA lwa_mpara_tab TYPE vseomepara.
*    LOOP AT im_vseo_tabs-mpara_tab INTO lwa_mpara_tab
*      WHERE clsname = me-&gt;class_name.
*      APPEND lwa_mpara_tab TO me-&gt;parameters.
*    ENDLOOP.

* Exceptions
    DATA lwa_mexce_tab TYPE vseoexcep.
    LOOP AT im_vseo_tabs-mexce_tab INTO lwa_mexce_tab
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_mexce_tab TO me-&gt;exceps.
    ENDLOOP.

* Interfaces
    DATA lwa_VSEOIMPLEM TYPE VSEOIMPLEM.
    LOOP AT im_vseo_tabs-iimpl_tab INTO lwa_VSEOIMPLEM
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_VSEOIMPLEM TO me-&gt;implementings.
    ENDLOOP.

* Types
    DATA lwa_VSEOTYPE TYPE VSEOTYPE.
    LOOP AT im_vseo_tabs-types_tab INTO lwa_VSEOTYPE
      WHERE clsname = me-&gt;class_name.
      APPEND lwa_VSEOTYPE TO me-&gt;types.
    ENDLOOP.


endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS_GLOBAL" VERSION="1" LANGU="E" DESCRIPT="ABAP global class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_CLASS">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*----------------------------------------------------------------------*
*       CLASS zcl_Wb_Class_Global_Test DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS zcl_wb_class_global_test DEFINITION FOR TESTING
  FINAL
  CREATE PUBLIC
  DURATION SHORT
  RISK LEVEL HARMLESS
.

  PUBLIC SECTION.

    METHODS load_class_loaded
    FOR TESTING .
    METHODS load_class_dont_exist
    FOR TESTING .
    METHODS load_class_is_interface
    FOR TESTING .
    METHODS load_class_is_model_only
    FOR TESTING .
  PROTECTED SECTION.

*  GIVEN
    METHODS given_class_is
      IMPORTING
        !im_class_name TYPE seoclsname .
    METHODS given_class_exist .
    METHODS given_class_dont_exist .
    METHODS given_class_is_interface .
    METHODS given_class_model_only .
*  WHEN
    METHODS when_load .
*  THEN
    METHODS then_class_loaded .
    METHODS then_class_not_loaded .
    METHODS then_exception_raised
      IMPORTING
        !im_class_name TYPE seoclsname .
    METHODS then_no_exception_raised .
  PRIVATE SECTION.
    METHODS setup.
    METHODS teardown.
    DATA o_wb_global_class TYPE REF TO zcl_wb_class_global .
    DATA o_wb_exception TYPE REF TO zcx_wb_objects .
ENDCLASS.       &quot;zcl_Wb_Class_Global_Test


*----------------------------------------------------------------------*
*       CLASS zcl_Wb_Class_Global_Test IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS zcl_wb_class_global_test IMPLEMENTATION.

  METHOD setup.
    CLEAR me-&gt;o_wb_global_class.
    CLEAR me-&gt;o_wb_exception.

  ENDMETHOD.       &quot;setup


  METHOD teardown.

  ENDMETHOD.       &quot;teardown


  METHOD given_class_dont_exist.
    given_class_is( &apos;ZCL_NOT_CREATED_CLASS&apos; ).
  ENDMETHOD.                    &quot;given_class_dont_exist



  METHOD given_class_exist.
    given_class_is( &apos;ZCL_WB_CLASS_GLOBAL&apos; ).
  ENDMETHOD.                    &quot;given_class_exist

  METHOD given_class_is.

    DATA lwa_seoclskey TYPE seoclskey.
    lwa_seoclskey-clsname = im_class_name.

    CREATE OBJECT me-&gt;o_wb_global_class
      EXPORTING
        im_clskey                    = lwa_seoclskey
*       im_version                   = SEOC_VERSION_INACTIVE
*       im_state                     = &apos;1&apos;
*       im_with_descriptions         = SEOX_TRUE
*       im_resolve_eventhandler_info = SEOX_FALSE
*       im_with_master_language      = SEOX_FALSE
*       im_with_enhancements         = SEOX_FALSE
*       im_read_active_enha          = SEOX_FALSE
*       im_enha_action               = SEOX_FALSE
*       im_ignore_switches           = &apos;X&apos;
      .

  ENDMETHOD.                    &quot;given_class_is


  METHOD given_class_is_interface.
    given_class_is( &apos;ZIF_WB_FAKE_INTERFACE&apos; ).
  ENDMETHOD.                    &quot;given_class_is_interface


  METHOD given_class_model_only.
* MODEL ONLY seems not exist on NetWeaver 7.31 - Is that right?
    given_class_is( &apos;ZCL_WB_FAKE_MODEL_ONLY&apos; ).
  ENDMETHOD.                    &quot;given_class_model_only


  METHOD load_class_dont_exist.

    given_class_dont_exist( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_CLASS_DONT_EXIST&apos; ).

  ENDMETHOD.                    &quot;LOAD_CLASS_DONT_EXIST


  METHOD load_class_is_interface.

    given_class_is_interface( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_IS_INTERFACE&apos; ).

  ENDMETHOD.                    &quot;load_class_is_interface


  METHOD load_class_is_model_only.

    given_class_model_only( ).
    when_load( ).
    then_class_not_loaded( ).
    then_exception_raised( &apos;ZCX_CLASS_IS_MODEL_ONLY&apos; ).

  ENDMETHOD.                    &quot;load_class_is_model_only

  METHOD load_class_loaded.

    given_class_exist( ).
    when_load( ).
    then_class_loaded( ).
    then_no_exception_raised( ).

  ENDMETHOD.                    &quot;LOAD_CLASS_LOADED

  METHOD then_class_loaded.

    cl_aunit_assert=&gt;assert_not_initial(
      EXPORTING
        act              = me-&gt;o_wb_global_class-&gt;class-clsname    &quot; Actual Data Object
        msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
    ).


  ENDMETHOD.                    &quot;then_class_loaded

  METHOD then_class_not_loaded.

    cl_aunit_assert=&gt;assert_initial(
      EXPORTING
        act              = me-&gt;o_wb_global_class-&gt;class-clsname    &quot; Actual Data Object
        msg              = &apos;Class name not loaded&apos;    &quot; Message in Case of Error
    ).

  ENDMETHOD.                    &quot;then_class_not_loaded


  METHOD then_exception_raised.

* TODO: how to dynamically assert that a specific exception was thrown?

    cl_aunit_assert=&gt;assert_bound(
      EXPORTING
        act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
    ).

  ENDMETHOD.                    &quot;then_exception_raised


  METHOD then_no_exception_raised.

    cl_aunit_assert=&gt;assert_not_bound(
      EXPORTING
        act              = me-&gt;o_wb_exception    &quot; Reference Variable to Be Checked
*        msg              =     &quot; Error Message
    ).
  ENDMETHOD.                    &quot;then_no_exception_raised


  METHOD when_load.

    TRY .
        me-&gt;o_wb_global_class-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects INTO me-&gt;o_wb_exception.

    ENDTRY.

  ENDMETHOD.                    &quot;when_load


ENDCLASS.       &quot;zcl_Wb_Class_Global_Test</localTestClasses>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CLSKEY" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOCLSKEY" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABATTRIB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABEVENT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHCLASSTABIMPLEMENTING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHMETH_TABHEADER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHANCEMENT_TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ENHTYPE_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="ENHA_ACTION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="EXPLORE_IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_INT_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="EXPLORE_INHERITANCE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOK_CLS_TYPEINFOS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="IGNORE_SWITCHES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR1" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="READ_ACTIVE_ENHA" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="RESOLVE_EVENTHANDLER_INFO" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="STATE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOSTATE" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="VERSION" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOVERSION" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_DESCRIPTIONS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_ENHANCEMENTS" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOX_BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_CLASS_GLOBAL" REFCLSNAME="ZCL_WB_CLASS" VERSION="1" MTDNAME="ZIF_WB_OBJECT~LOAD" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS_GLOBAL" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>METHOD zif_wb_object~load.

  CALL FUNCTION &apos;SEO_CLASS_TYPEINFO_GET&apos;
    EXPORTING
      clskey                        = me-&gt;clskey
      version                       = me-&gt;version
      state                         = me-&gt;state
      with_descriptions             = me-&gt;with_descriptions
      resolve_eventhandler_typeinfo = me-&gt;resolve_eventhandler_info
      with_master_language          = me-&gt;with_master_language
      with_enhancements             = me-&gt;with_enhancements
      read_active_enha              = me-&gt;read_active_enha
      enha_action                   = me-&gt;enha_action
      ignore_switches               = me-&gt;ignore_switches
    IMPORTING
      class                         = me-&gt;class
      attributes                    = me-&gt;attributes
      methods                       = me-&gt;methods
      events                        = me-&gt;events
      types                         = me-&gt;types
      parameters                    = me-&gt;parameters
      exceps                        = me-&gt;exceps
      implementings                 = me-&gt;implementings
      inheritance                   = me-&gt;inheritance
      redefinitions                 = me-&gt;redefinitions
      impl_details                  = me-&gt;impl_details
      friendships                   = me-&gt;friendships
      typepusages                   = me-&gt;typepusages
      clsdeferrds                   = me-&gt;clsdeferrds
      intdeferrds                   = me-&gt;intdeferrds
      explore_inheritance           = me-&gt;explore_inheritance
      explore_implementings         = me-&gt;explore_implementings
      aliases                       = me-&gt;aliases
      enhancement_methods           = me-&gt;enhancement_methods
      enhancement_attributes        = me-&gt;enhancement_attributes
      enhancement_events            = me-&gt;enhancement_events
      enhancement_implementings     = me-&gt;enhancement_implementings
      enhancement_types             = me-&gt;enhancement_types
    EXCEPTIONS
      not_existing                  = 1
      is_interface                  = 2
      model_only                    = 3
      OTHERS                        = 4.

  CASE sy-subrc.
    WHEN 1.
      RAISE EXCEPTION TYPE zcx_class_dont_exist.
    WHEN 2.
      RAISE EXCEPTION TYPE zcx_is_interface.
    WHEN 3.
      RAISE EXCEPTION TYPE zcx_class_is_model_only.
  ENDCASE.

ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_CLSKEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCLSKEY"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_VERSION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOVERSION" PARVALUE="SEOC_VERSION_INACTIVE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_STATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOSTATE" PARVALUE="&apos;1&apos;"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_DESCRIPTIONS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_TRUE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_RESOLVE_EVENTHANDLER_INFO" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_MASTER_LANGUAGE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_WITH_ENHANCEMENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="7 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_READ_ACTIVE_ENHA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="8 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_ENHA_ACTION" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOX_BOOLEAN" PARVALUE="SEOX_FALSE"/>
   <parameter CLSNAME="ZCL_WB_CLASS_GLOBAL" CMPNAME="CONSTRUCTOR" SCONAME="IM_IGNORE_SWITCHES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="10 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR1" PARVALUE="&apos;X&apos;"/>
   <source>method CONSTRUCTOR.
    super-&gt;constructor( ).
    me-&gt;clskey                    = im_clskey.
    me-&gt;version                   = im_version.
    me-&gt;state                     = im_state.
    me-&gt;with_descriptions         = im_with_descriptions.
    me-&gt;resolve_eventhandler_info = im_resolve_eventhandler_info.
    me-&gt;with_master_language      = im_with_master_language.
    me-&gt;with_enhancements         = im_with_enhancements.
    me-&gt;read_active_enha          = im_read_active_enha.
    me-&gt;enha_action               = im_enha_action.
    me-&gt;ignore_switches           = im_ignore_switches.

endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_CLASS" VERSION="1" LANGU="E" DESCRIPT="Generic class" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSABSTRCT="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_CLASS" REFCLSNAME="ZIF_WB_OBJECT" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <typeUsage CLSNAME="ZCL_WB_CLASS" TYPEGROUP="SEOO" VERSION="1" TPUTYPE="0" IMPLICIT="X"/>
  <forwardDeclaration>SEOO</forwardDeclaration>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="ALIASES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ALIASES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="ATTRIBUTES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_ATTRIBUTES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="CLASS" VERSION="1" LANGU="E" DESCRIPT="Generierte Tabelle zu einem View" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOCLASS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="CLSDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_CLSDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="EVENTS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_EVENTS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="EXCEPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_EXCEPTIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="FRIENDSHIPS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOF_FRIENDSHIPS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="IMPLEMENTINGS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_IMPLEMENTINGS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="IMPL_DETAILS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_REDEFINITIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="INHERITANCE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="VSEOEXTEND" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="INTDEFERRDS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_INTDEFERRDS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="METHODS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_METHODS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="PARAMETERS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOS_PARAMETERS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="REDEFINITIONS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOR_REDEFINITIONS_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="TYPEPUSAGES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOT_TYPEPUSAGES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_CLASS" CMPNAME="TYPES" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SEOO_TYPES_R" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS" CPDNAME="ZIF_WB_OBJECT~LOAD">
   <source>method ZIF_WB_OBJECT~LOAD.

endmethod.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_WB_CLASS" CPDNAME="ZIF_WB_OBJECT~WRITE">
   <source>method ZIF_WB_OBJECT~WRITE.

  WRITE:
    &apos;Class:&apos;,
    me-&gt;class-clsname,
    &apos; - &apos;,
    me-&gt;class-descript.
  NEW-LINE.

*    WRITE me-&gt;class-version           .  NEW-LINE.
*    WRITE me-&gt;class-langu             .  NEW-LINE.
*    WRITE me-&gt;class-descript          .  NEW-LINE.
*    WRITE me-&gt;class-uuid              .  NEW-LINE.
*    WRITE me-&gt;class-category          .  NEW-LINE.
*    WRITE me-&gt;class-exposure          .  NEW-LINE.
*    WRITE me-&gt;class-state             .  NEW-LINE.
*    WRITE me-&gt;class-release           .  NEW-LINE.
*    WRITE me-&gt;class-author            .  NEW-LINE.
*    WRITE me-&gt;class-createdon         .  NEW-LINE.
*    WRITE me-&gt;class-changedby         .  NEW-LINE.
*    WRITE me-&gt;class-changedon         .  NEW-LINE.
*    WRITE me-&gt;class-chgdanyby         .  NEW-LINE.
*    WRITE me-&gt;class-chgdanyon         .  NEW-LINE.
*    WRITE me-&gt;class-clsembed          .  NEW-LINE.
*    WRITE me-&gt;class-clsabstrct        .  NEW-LINE.
*    WRITE me-&gt;class-clsfinal          .  NEW-LINE.
*    WRITE me-&gt;class-clsccincl         .  NEW-LINE.
*    WRITE me-&gt;class-remote            .  NEW-LINE.
*    WRITE me-&gt;class-fixpt             .  NEW-LINE.
*    WRITE me-&gt;class-varcl             .  NEW-LINE.
*    WRITE me-&gt;class-unicode           .  NEW-LINE.
*    WRITE me-&gt;class-rstat             .  NEW-LINE.
*    WRITE me-&gt;class-clsdefatt         .  NEW-LINE.
*    WRITE me-&gt;class-clsdefmtd         .  NEW-LINE.
*    WRITE me-&gt;class-clsdefint         .  NEW-LINE.
*    WRITE me-&gt;class-clsbcimpl         .  NEW-LINE.
*    WRITE me-&gt;class-r3release         .  NEW-LINE.
*    WRITE me-&gt;class-clsbctrans        .  NEW-LINE.
*    WRITE me-&gt;class-clsbccat          .  NEW-LINE.
*    WRITE me-&gt;class-clsaddon          .  NEW-LINE.
*    WRITE me-&gt;class-msg_id            .  NEW-LINE.
*    WRITE me-&gt;class-clsbcnodel        .  NEW-LINE.
*    WRITE me-&gt;class-clsproxy          .  NEW-LINE.
*    WRITE me-&gt;class-clssharedmemory   .  NEW-LINE.
*    WRITE me-&gt;class-with_unit_tests   .  NEW-LINE.
*    WRITE me-&gt;class-duration_type     .  NEW-LINE.
*    WRITE me-&gt;class-risk_level        .  NEW-LINE.
*    WRITE me-&gt;class-within_package    .  NEW-LINE.

* attributes
  DATA lwa_attributes TYPE vseoattrib.
  WRITE: &apos;Attributes&apos; COLOR 3. NEW-LINE.

  LOOP AT me-&gt;attributes INTO lwa_attributes.
*      WRITE lwa_attributes-clsname        . NEW-LINE.
    WRITE lwa_attributes-cmpname        . NEW-LINE.
*      WRITE lwa_attributes-version        . NEW-LINE.
*      WRITE lwa_attributes-langu          . NEW-LINE.
*      WRITE lwa_attributes-descript       . NEW-LINE.
*      WRITE lwa_attributes-alias          . NEW-LINE.
*      WRITE lwa_attributes-exposure       . NEW-LINE.
*      WRITE lwa_attributes-state          . NEW-LINE.
*      WRITE lwa_attributes-editorder      . NEW-LINE.
*      WRITE lwa_attributes-author         . NEW-LINE.
*      WRITE lwa_attributes-createdon      . NEW-LINE.
*      WRITE lwa_attributes-changedby      . NEW-LINE.
*      WRITE lwa_attributes-changedon      . NEW-LINE.
*      WRITE lwa_attributes-attdecltyp     . NEW-LINE.
*      WRITE lwa_attributes-attdynamic     . NEW-LINE.
*      WRITE lwa_attributes-attgetmtd      . NEW-LINE.
*      WRITE lwa_attributes-attsetmtd      . NEW-LINE.
*      WRITE lwa_attributes-attrdonly      . NEW-LINE.
*      WRITE lwa_attributes-attvalue       . NEW-LINE.
*      WRITE lwa_attributes-attpersist     . NEW-LINE.
*      WRITE lwa_attributes-attexpvirt     . NEW-LINE.
*      WRITE lwa_attributes-typtype        . NEW-LINE.
*      WRITE lwa_attributes-type           . NEW-LINE.
*      WRITE lwa_attributes-tableof        . NEW-LINE.
*      WRITE lwa_attributes-srcrow1        . NEW-LINE.
*      WRITE lwa_attributes-srccolumn1     . NEW-LINE.
*      WRITE lwa_attributes-srcrow2        . NEW-LINE.
*      WRITE lwa_attributes-srccolumn2     . NEW-LINE.
*      WRITE lwa_attributes-refclsname     . NEW-LINE.
*      WRITE lwa_attributes-refcmpname     . NEW-LINE.
*      WRITE lwa_attributes-locked         . NEW-LINE.
*      WRITE lwa_attributes-attkeyfld      . NEW-LINE.
*      WRITE lwa_attributes-attbusobj      . NEW-LINE.
*      WRITE lwa_attributes-r3release      . NEW-LINE.
*      WRITE lwa_attributes-typesrc_leng   . NEW-LINE.
*      WRITE lwa_attributes-typesrc        . NEW-LINE.
  ENDLOOP.

  DATA lwa_method TYPE seoo_method_r.
  WRITE: &apos;Methods&apos; COLOR 3. NEW-LINE.
  LOOP AT me-&gt;methods INTO lwa_method.
    WRITE lwa_method-cmpname. NEW-LINE.
  ENDLOOP.
  ULINE.

endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <INTF CLSNAME="ZIF_WB_OBJECT" VERSION="1" LANGU="E" DESCRIPT="Workbench Object" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="LOAD" VERSION="1" LANGU="E" DESCRIPT="Load wb objects details" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
   <exception CLSNAME="ZIF_WB_OBJECT" CMPNAME="LOAD" SCONAME="ZCX_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="WB Objects generic exception" MTDTYPE="0" EDITORDER="1 "/>
  </method>
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="TO_STRING" VERSION="1" LANGU="E" DESCRIPT="Get string representation of object" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0"/>
  <method CLSNAME="ZIF_WB_OBJECT" CMPNAME="WRITE" VERSION="1" LANGU="E" DESCRIPT="Write representation of object" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0"/>
 </INTF>
 <INTF CLSNAME="ZIF_WB_SEARCH_CRITERIA" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <types CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="TY_RA_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="TY_RA_PACKAGES" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="6 " SRCCOLUMN1="4 " SRCROW2="6 " SRCCOLUMN2="49 " TYPESRC_LENG="48 " TYPESRC="ty_ra_packages    TYPE RANGE OF tdevc-devclass
"/>
  <types CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="TY_RA_REPORTS" VERSION="1" LANGU="E" DESCRIPT="TY_RA_REPORTS" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="8 " SRCCOLUMN1="4 " SRCROW2="8 " SRCCOLUMN2="51 " TYPESRC_LENG="50 " TYPESRC="ty_ra_reports     TYPE RANGE OF reposrc-progname
"/>
  <types CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="TY_RA_CLASSES" VERSION="1" LANGU="E" DESCRIPT="TY_RA_CLASSES" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="10 " SRCCOLUMN2="51 " TYPESRC_LENG="50 " TYPESRC="ty_ra_classes     TYPE RANGE OF seoclass-clsname
"/>
  <types CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="TY_RA_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="TY_RA_INTERFACES" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="12 " SRCCOLUMN1="4 " SRCROW2="12 " SRCCOLUMN2="51 " TYPESRC_LENG="50 " TYPESRC="ty_ra_interfaces  TYPE RANGE OF seoclass-clsname
"/>
  <attribute CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="R_CLASSES" VERSION="1" LANGU="E" DESCRIPT="R_CLASSES" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_RA_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="R_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="R_INTERFACES" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_RA_INTERFACES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="R_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="R_PACKAGES" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_RA_PACKAGES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="R_REPORTS" VERSION="1" LANGU="E" DESCRIPT="R_REPORTS" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TY_RA_REPORTS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <method CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" VERSION="1" LANGU="E" DESCRIPT="FACTORY" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" SCONAME="IM_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="IM_PACKAGES" CMPTYPE="1" MTDTYPE="0" EDITORDER="9 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_RA_PACKAGES" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" SCONAME="IM_REPORTS" VERSION="1" LANGU="E" DESCRIPT="IM_REPORTS" CMPTYPE="1" MTDTYPE="0" EDITORDER="10 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_RA_REPORTS" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" SCONAME="IM_CLASSES" VERSION="1" LANGU="E" DESCRIPT="IM_CLASSES" CMPTYPE="1" MTDTYPE="0" EDITORDER="11 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_RA_CLASSES" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" SCONAME="IM_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="IM_INTERFACES" CMPTYPE="1" MTDTYPE="0" EDITORDER="12 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="TY_RA_INTERFACES" PAROPTIONL="X"/>
   <parameter CLSNAME="ZIF_WB_SEARCH_CRITERIA" CMPNAME="FACTORY" SCONAME="RE_SEARCH_CRITERIA" VERSION="1" LANGU="E" DESCRIPT="RE_SEARCH_CRITERIA" CMPTYPE="1" MTDTYPE="0" EDITORDER="13 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_WB_SEARCH_CRITERIA"/>
  </method>
 </INTF>
 <PROG NAME="ZIN_WB_SCANNER_OBJECTS" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" LEVL="702" RMAND="000" RLOAD="D" FIXPT="X" LDBNAME="D$S">
  <textPool>
   <language SPRAS="D">
    <textElement ID="R" ENTRY="Include LS_ABAP_OBJECTS_SCANTOP" LENGTH="31 "/>
   </language>
  </textPool>
  <source>INCLUDE ZIN_WB_SCANNER_OBJECTS.

type-pools:
  sana,
  abap,
  saboo.

class statement_illegal definition inheriting from cx_no_check final.
endclass.

class scanner definition final.
  public section.

    constants:
      begin of const,
        max_line_size type i value 255,
        begin of aunit_duration,
          short  type vseoclass-duration_type value 12,
          medium type vseoclass-duration_type value 24,
          long   type vseoclass-duration_type value 36,
        end of aunit_duration,
        begin of aunit_risk,
          harmless  type vseoclass-risk_level value 11,
          dangerous type vseoclass-risk_level value 22,
          critical  type vseoclass-risk_level value 33,
        end of aunit_risk,
        begin of exposure,
          public    type vseoclass-exposure value 2,
          protected type vseoclass-exposure value 1,
          package   type vseoclass-exposure value 3,
          private   type vseoclass-exposure value 0,
        end of exposure,
      end of const.

    class-methods create importing resolve_includes type seox_boolean optional
                         exporting scanner type ref to scanner
                                   error_source type syrepid
                         changing  sourc_tab type saboo_sourt.

    methods scan_source importing clsname type seoclass-clsname optional
                                  superclsname type seoclass-clsname optional
                                  exposure type vseoclass-exposure default 2
                        returning value(vseo_tabs) type saboo_vseot.
    methods scan_source_for_method_impls
                        returning value(method_impls) type saboo_method_impl_tab.

  private section.

    types:
      begin of scope_rec_type,
        clsname      type c length 30,
        superclsname type c length 30,
        is_interface type c length  1,
        exposure     type n length  1,
      end of scope_rec_type,
      scope_sta_type type standard table of scope_rec_type with non-unique key clsname,
*     global fields
      begin of me_priv_type,
*       tables for SCAN
        state_tab type saboo_statt,
        token_tab type saboo_tokstx,
        sourc_tab type saboo_sourt,
*       global state
        clsname      type c length 30,
        superclsname type c length 30,
        is_interface type c length  1,
        cmpname      type c length  61,
        version      type n length  1,
        langu        type c length  1,
        exposure     type n length  1,
        state        type n length  1,
        mtdtype      type n length  1,
*       nested scope stack &amp; counter
        nested_sc type i,
        scope_sta type scope_sta_type,
*       nested BEGIN ... END type declaration
        inside_begin_end type i,
        begin_end_col    type i,
        begin_end_row    type i,
*       counter for editor order
        editor_order type i,
      end of me_priv_type.

    data:
      me_priv type me_priv_type boxed.

    methods reset.

    methods resolve_includes changing sourc_tab type saboo_sourt
                                      error_source type syst-repid.
    methods source_tab_to_char importing typsr_rec type saboo_typsr
                               changing char type c.

    methods insert_class importing state_begin type i
                                   state_end   type i
                         changing  class_tab   type saboo_clast
                                   exted_tab   type saboo_extet
                                   frnds_tab   type saboo_frndt.
    methods insert_inter importing state_pos type i
                         changing  inter_tab type saboo_intet.
    methods insert_attri importing value(attdecltyp) type n
                                   state_begin       type i
                                   state_end         type i
                         changing  attri_tab         type saboo_attrt
                                   typsr_tab         type saboo_typst.
    methods insert_metho importing value(mtddecltyp) type n
                                   state_pos         type i
                                   state_end         type i
                         changing  metho_tab         type saboo_metht
                                   redef_tab         type saboo_redet
                                   mpara_tab         type saboo_mpart
                                   mexce_tab         type saboo_mexct.
    methods insert_event importing value(evtdecltyp) type n
                                   state_pos         type i
                                   state_end         type i
                         changing  event_tab         type saboo_event
                                   epara_tab         type saboo_epart.
    methods insert_iimpl importing state_pos type i
                                   state_end type i
                         changing  iimpl_tab type saboo_iimpt
                                   redef_tab type saboo_redet.
    methods insert_types importing state_begin type i
                                   state_end   type i
                         changing  types_tab   type saboo_typet
                                   typsr_tab   type saboo_typst.
    methods insert_iincl importing state_pos type i
                         changing  iincl_tab type saboo_iinct.
    methods insert_alias importing state_pos type i
                                   state_end type i
                         changing  alias_tab type saboo_aliat.
    methods insert_cload importing state_pos type i
                         changing  cload_tab type saboo_cloat.
    methods insert_iload importing state_pos type i
                         changing  iload_tab type saboo_iloat.
    methods insert_tpool importing state_pos type i
                         changing  tpool_tab type saboo_tpoot.
    methods insert_frnds importing clsname   type csequence
                                   state_pos type i
                                   state_end type i
                         changing  frnds_tab type saboo_frndt.
    methods insert_mpara importing state_end type i
                         changing  curre_pos type i
                                   mpara_tab type saboo_mpart.
    methods insert_mexec importing state_end type i
                         changing  curre_pos type i
                                   mtdnewexc type seonewexc
                                   mexce_tab type saboo_mexct.
    methods insert_epara importing state_end type i
                         changing  curre_pos type i
                                   epara_tab type saboo_epart.
    methods write_mpara importing value(pardecltyp) type n
                                  state_end         type i
                        changing  curre_pos         type i
                                  mpara_tab         type saboo_mpart.
    methods write_epara importing value(pardecltyp) type n
                                  state_end         type i
                        changing  curre_pos         type i
                                  epara_tab         type saboo_epart.


endclass.</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_FAKES" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_FAKES" LENGTH="35 "/>
   </language>
  </textPool>
  <source>include ZI_ZCL_WB_CLASS_LOCAL_STUB.
include ZI_ZCL_WB_CLASS_LOCAL_MOCK.</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_MOCK" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_MOCK" LENGTH="34 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_mock DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_mock DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS create_att_class
      RETURNING value(re_t_vseo_tabs_class) TYPE saboo_vseot-class_tab.

ENDCLASS.                    &quot;lcl_wb_class_local_mock DEFINITION


*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_mock IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_mock IMPLEMENTATION.
  METHOD create_att_class.

  ENDMETHOD.                    &quot;create_att_class
ENDCLASS.                    &quot;lcl_wb_class_local_mock IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZI_ZCL_WB_CLASS_LOCAL_STUB" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_ZCL_WB_CLASS_LOCAL_STUB" LENGTH="34 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_stub DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_stub DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS create_class_name
      RETURNING value(re_class_name) TYPE seoclsname.

    CLASS-METHODS create_vseo_tabs_class
      RETURNING value(re_t_vseo_tabs_class) TYPE saboo_vseot-class_tab.

ENDCLASS.                    &quot;lcl_wb_class_local_stub DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_wb_class_local_stub IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_wb_class_local_stub IMPLEMENTATION.

  METHOD create_class_name.
    re_class_name = &apos;CLSNAME&apos;.
  ENDMETHOD.                    &quot;create_class_name


  METHOD create_vseo_tabs_class.
    DATA lwa_vseo_class TYPE vseoclass.
    lwa_vseo_class-clsname = lcl_wb_class_local_stub=&gt;create_class_name( ).
*    lwa_vseo_class-version
*    lwa_vseo_class-langu
*    lwa_vseo_class-descript
*    lwa_vseo_class-uuid
*    lwa_vseo_class-category
*    lwa_vseo_class-exposure
*    lwa_vseo_class-state
*    lwa_vseo_class-release
*    lwa_vseo_class-author
*    lwa_vseo_class-createdon
*    lwa_vseo_class-changedby
*    lwa_vseo_class-changedon
*    lwa_vseo_class-chgdanyby
*    lwa_vseo_class-chgdanyon
*    lwa_vseo_class-clsembed
*    lwa_vseo_class-clsabstrct
*    lwa_vseo_class-clsfinal
*    lwa_vseo_class-clsccincl
*    lwa_vseo_class-remote
*    lwa_vseo_class-fixpt
*    lwa_vseo_class-varcl
*    lwa_vseo_class-unicode
*    lwa_vseo_class-rstat
*    lwa_vseo_class-clsdefatt
*    lwa_vseo_class-clsdefmtd
*    lwa_vseo_class-clsdefint
*    lwa_vseo_class-clsbcimpl
*    lwa_vseo_class-r3release
*    lwa_vseo_class-clsbctrans
*    lwa_vseo_class-clsbccat
*    lwa_vseo_class-clsaddon
*    lwa_vseo_class-msg_id
*    lwa_vseo_class-clsbcnodel
*    lwa_vseo_class-clsproxy
*    lwa_vseo_class-clssharedmemory
*    lwa_vseo_class-with_unit_tests
*    lwa_vseo_class-duration_type
*    lwa_vseo_class-risk_level
*    lwa_vseo_class-within_package

    APPEND lwa_vseo_class TO re_t_vseo_tabs_class.
  ENDMETHOD.                    &quot;create_vseo_tabs_class
ENDCLASS.                    &quot;lcl_wb_class_local_stub IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZWB_LOCAL_CLASS_EXAMPLE" VARCL="X" SUBC="I" RMAND="800" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="ZWB_LOCAL_CLASS_EXAMPLE" LENGTH="23 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZWB_LOCAL_CLASS_EXAMPLE
*&amp;---------------------------------------------------------------------*

INTERFACE lif_intf_1.
  DATA aaa TYPE i.
  DATA bbb TYPE c.

  METHODS do_1.
  METHODS do_2
    IMPORTING
      im_aaa TYPE i.

  METHODS do_3
    IMPORTING
      im_iii TYPE i
    RETURNING VALUE(re_bbb) TYPE char2.

ENDINTERFACE.


CLASS lcl_class_1 DEFINITION.

  PUBLIC SECTION.
    METHODS constuctor.


  PROTECTED SECTION.
    DATA att_1 TYPE i.

  PRIVATE SECTION.

    METHODS do_something
      IMPORTING
        im_fp TYPE i.

ENDCLASS.                    &quot;lcl_class_1 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_class_1 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_1 IMPLEMENTATION.

  METHOD constuctor.
    att_1 = im_fp.
  ENDMETHOD.                    &quot;constuctor

  METHOD do_something.
    WAIT UP TO 1 SECONDS.
  ENDMETHOD.                    &quot;do_something
ENDCLASS.                    &quot;lcl_class_1 IMPLEMENTATION


*----------------------------------------------------------------------*
*       CLASS lcl_class_2 DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_2 DEFINITION INHERITING FROM lcl_class_1.
  PUBLIC SECTION.
  DATA att_2 TYPE string.
  PRIVATE SECTION.
  METHODS do_something REDEFINITION.
ENDCLASS.                    &quot;lcl_class_2 DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_class_2 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_class_2 IMPLEMENTATION.
  METHOD do_something.
    WAIT UP TO me-&gt;att_1 SECONDS.
  ENDMETHOD.                    &quot;do_something

ENDCLASS.                    &quot;lcl_class_2 IMPLEMENTATION


CLASS lcl_class_3 DEFINITION..
  DATA aaa TYPE i.
  DATA bbb TYPE c.

  METHODS do_1.
  METHODS do_2
    IMPORTING
      im_aaa TYPE i.

  METHODS do_3
    IMPORTING
      im_iii TYPE i
    RETURNING VALUE(re_bbb) TYPE c.

ENDCLASS.</source>
 </PROG>
 <PROG NAME="ZWB_OBJECTS_DEMO1" VARCL="X" SUBC="1" RSTAT="T" RMAND="001" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Classes and interfaces (globals and locals)" LENGTH="43 "/>
    <textElement ID="S" KEY="P_CLASS" ENTRY="        Global Class" LENGTH="20 "/>
    <textElement ID="S" KEY="P_INTER" ENTRY="        Global Interface" LENGTH="24 "/>
    <textElement ID="S" KEY="P_REPOR" ENTRY="        Program/Include Name" LENGTH="28 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZWB_OBJECTS_DEMO1
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  zwb_objects_demo1.

PARAMETERS p_class TYPE seoclass-clsname.
PARAMETERS p_inter TYPE seoclass-clsname.
PARAMETERS p_repor TYPE reposrc-progname.


START-OF-SELECTION.

  DATA o_class TYPE REF TO zcl_wb_class.

  IF p_class IS NOT INITIAL AND
    p_inter IS NOT INITIAL AND
    p_repor IS NOT INITIAL.
    MESSAGE &apos;Fill a class or an interface or a report name&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
    STOP.
  ENDIF.


* Global Class
  IF p_class IS NOT INITIAL.
    DATA o_global_class TYPE REF TO zcl_wb_class_global.
    DATA wa_seoclskey TYPE seoclskey.

    wa_seoclskey-clsname = p_class.
    CREATE OBJECT o_global_class
      EXPORTING
        im_clskey                    = wa_seoclskey
*       im_version                   = SEOC_VERSION_INACTIVE
*       im_state                     = &apos;1&apos;
*       im_with_descriptions         = SEOX_TRUE
*       im_resolve_eventhandler_info = SEOX_FALSE
*       im_with_master_language      = SEOX_FALSE
*       im_with_enhancements         = SEOX_FALSE
*       im_read_active_enha          = SEOX_FALSE
*       im_enha_action               = SEOX_FALSE
*       im_ignore_switches           = &apos;X&apos;
      .

    TRY .
        o_global_class-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception

    ENDTRY.

    o_global_class-&gt;to_string( ).
    STOP.

  ENDIF.


* Global Interface
  IF p_inter IS NOT INITIAL.
    DATA o_global_interface TYPE REF TO zcl_wb_interface_global.
    DATA wa_intkey TYPE seoclskey.

    wa_intkey-clsname = p_inter.

    CREATE OBJECT o_global_interface
      EXPORTING
        im_intkey               = wa_intkey
*       im_version              = SEOC_VERSION_INACTIVE
*       im_state                = &apos;1&apos;
*       im_with_master_language = SEOX_FALSE
*       im_with_enhancements    = SEOX_FALSE
*       im_read_active_enha     = SEOX_FALSE
*       im_enha_action          = SEOX_FALSE
*       im_ignore_switches      = &apos;X&apos;
      .


    TRY .
        o_global_interface-&gt;zif_wb_object~load( ).
      CATCH zcx_wb_objects.    &quot; WB Objects generic exception

    ENDTRY.

    o_global_interface-&gt;to_string( ).
    STOP.
  ENDIF.


* Local classes and interfaces
  IF p_repor IS NOT INITIAL.

    DATA itab_local_class TYPE ztt_wb_class_local.
    DATA o_local_class TYPE REF TO zcl_wb_class_local.
    itab_local_class = zcl_wb_class_local=&gt;load_all_classes( im_program = p_repor ).

    LOOP AT itab_local_class INTO o_local_class.
      o_local_class-&gt;to_string( ).
    ENDLOOP.

    DATA itab_local_interface TYPE ztt_wb_interface_local.
    DATA o_local_interface TYPE REF TO zcl_wb_interface_local.
    itab_local_interface = zcl_wb_interface_local=&gt;load_all_interfaces( im_program = p_repor ).

    LOOP AT itab_local_interface INTO o_local_interface.
      o_local_interface-&gt;to_string( ).
    ENDLOOP.

    STOP.
  ENDIF.</source>
 </PROG>
 <PROG NAME="ZYUML_WB_COLLECTIONS" VARCL="X" SUBC="I" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZYUML_WB_COLLECTIONS" LENGTH="28 "/>
   </language>
  </textPool>
  <source>****----------------------------------------------------------------------*
****       INTERFACE lif_wb_iterator
****----------------------------------------------------------------------*
****
****----------------------------------------------------------------------*
***INTERFACE lif_wb_iterator.
***
***ENDINTERFACE.                    &quot;lif_wb_iterator
***
****----------------------------------------------------------------------*
****       INTERFACE lif_wb_collection
****----------------------------------------------------------------------*
****
****----------------------------------------------------------------------*
***INTERFACE lif_wb_collection.
***
****  METHODS add.
****  METHODS remove.
****  METHODS clear.
****  METHODS is_empty RETURNING value(re_is_empty) TYPE abap_bool.
****  METHODS get_iterator.
****  METHODS size.
***
***ENDINTERFACE.                    &quot;lif_wb_collection
***
****---------------- ------------------------------------------------------*
****       INTERFACE lif_wb_object_set
****----------------------------------------------------------------------*
**** This interface represents a set of WB objects.
**** There might be different classes that somehow group together one
**** or more kind of WB objects. All those classes might have something
**** in common which in this case is this interface.
****----------------------------------------------------------------------*
***INTERFACE lif_wb_object_set.
***  &quot; TODO: implement some iterable / appendable
***  INTERFACES lif_wb_collection.
***  METHODS list_object_set.
***ENDINTERFACE.                    &quot;lif_wb_object_set
***
***
****----------------------------------------------------------------------*
****       INTERFACE lif_wb_object_set_itab
****----------------------------------------------------------------------*
**** This interface groups together many WB objects in a single internal
**** table. As a consequence this itab is generic in terms of which
**** WB object it stores.
****----------------------------------------------------------------------*
***INTERFACE lif_wb_object_set_itab.
***  INTERFACES lif_wb_object_set.
***  DATA t_wb_objects TYPE STANDARD TABLE OF REF TO zif_wb_object.
***ENDINTERFACE.                    &quot;lif_wb_object_set
***
***
****----------------------------------------------------------------------*
****       CLASS lcl_wb_object_set_itab DEFINITION
****----------------------------------------------------------------------*
**** This class represents a set of WB objects in the form of an internal
**** table
****----------------------------------------------------------------------*
***CLASS lcl_wb_object_set_itab DEFINITION.
***  PUBLIC SECTION.
***    INTERFACES lif_wb_object_set_itab.
***ENDCLASS.                    &quot;lcl_wb_object_set_itab DEFINITION
***
****----------------------------------------------------------------------*
****       CLASS lcl_wb_object_set_itab IMPLEMENTATION
****----------------------------------------------------------------------*
****
****----------------------------------------------------------------------*
***CLASS lcl_wb_object_set_itab IMPLEMENTATION.
***  METHOD lif_wb_object_set~list_object_set.
***  ENDMETHOD.                    &quot;lif_wb_object_set~list_object_set
***
***ENDCLASS.                    &quot;lcl_wb_object_set_itab IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="Z_WB_SCANNER_OBJECTS_TEST" VARCL="X" SUBC="1" RMAND="800" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Program Z_WB_SCANNER_OBJECTS_TEST" LENGTH="33 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  Z_WB_SCANNER_OBJECTS_TEST
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT  z_wb_scanner_objects_test.

PARAMETERS p_incl TYPE programm DEFAULT &apos;ZWB_LOCAL_CLASS_EXAMPLE&apos;.

START-OF-SELECTION.

  DATA t_r_local_class TYPE ztt_wb_class_local.
  DATA r_local_class   TYPE REF TO zcl_wb_class_local.

  t_r_local_class = zcl_wb_class_local=&gt;load_all_classes( p_incl ).

  LOOP AT t_r_local_class INTO r_local_class.
    r_local_class-&gt;zif_wb_object~load( ).
    r_local_class-&gt;to_string( ).
  ENDLOOP.

  &quot;BREAK-POINT.</source>
 </PROG>
 <TTYP TYPENAME="ZTT_WB_CLASS_LOCAL" DDLANGUAGE="E" ROWTYPE="ZCL_WB_CLASS_LOCAL" ROWKIND="R" DATATYPE="REF" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table of WB local classes" TYPELEN="000008" CTLENG="000000" CTDECIMALS="000000" REFTYPE="C" OCCURS="00000"/>
 <TTYP TYPENAME="ZTT_WB_INTERFACE_LOCAL" DDLANGUAGE="E" ROWTYPE="ZCL_WB_INTERFACE_LOCAL" ROWKIND="R" DATATYPE="REF" LENG="000000" DECIMALS="000000" ACCESSMODE="T" KEYDEF="D" KEYKIND="N" KEYFDCOUNT="0000" DDTEXT="Table of WB local interfaces" TYPELEN="000008" CTLENG="000000" CTDECIMALS="000000" REFTYPE="C" OCCURS="00000"/>
 <CLAS CLSNAME="ZCL_WB_SET_ITAB" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_SET_ITAB" REFCLSNAME="ZIF_WB_SET_ITAB" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <interfaceMethod CLSNAME="ZCL_WB_SET_ITAB" CPDNAME="ZIF_WB_SET~LIST_OBJECT_SET">
   <source>method ZIF_WB_SET~LIST_OBJECT_SET.


endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <INTF CLSNAME="ZIF_WB_COLLECTION" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X"/>
 <INTF CLSNAME="ZIF_WB_ITERATOR" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X"/>
 <INTF CLSNAME="ZIF_WB_SET" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <include CLSNAME="ZIF_WB_SET" REFCLSNAME="ZIF_WB_COLLECTION" VERSION="1" STATE="1"/>
  <method CLSNAME="ZIF_WB_SET" CMPNAME="LIST_OBJECT_SET" VERSION="1" LANGU="E" DESCRIPT="LIST_OBJECT_SET" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0"/>
 </INTF>
 <INTF CLSNAME="ZIF_WB_SET_ITAB" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <include CLSNAME="ZIF_WB_SET_ITAB" REFCLSNAME="ZIF_WB_COLLECTION" VERSION="1" STATE="1"/>
  <include CLSNAME="ZIF_WB_SET_ITAB" REFCLSNAME="ZIF_WB_SET" VERSION="1" STATE="1"/>
  <attribute CLSNAME="ZIF_WB_SET_ITAB" CMPNAME="T_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="T_WB_OBJECTS" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="4 " SRCROW2="9 " SRCCOLUMN2="59 " TYPESRC_LENG="58 " TYPESRC="t_wb_objects TYPE STANDARD TABLE OF REF TO zif_wb_object
"/>
 </INTF>
 <CLAS CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" VERSION="1" LANGU="E" DESCRIPT="ZCL_WB_MASS_LOADER_OO_SEARCHER" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" REFCLSNAME="ZIF_WB_MASS_LOADER" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="1 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="O_WB_OO_SEARCHER" VERSION="1" LANGU="E" DESCRIPT="O_WB_OO_SEARCHER" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_WB_SEARCHER_OO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CPDNAME="ZIF_WB_MASS_LOADER~MASS_LOAD">
   <source>METHOD zif_wb_mass_loader~mass_load.


    CREATE OBJECT re_wb_objects_set
      TYPE zcl_wb_set_itab.

    me-&gt;load_package_contents( CHANGING ch_o_wb_object_set = re_wb_objects_set ).
    me-&gt;load_programs( CHANGING ch_o_wb_object_set = re_wb_objects_set ).
    me-&gt;load_classes( CHANGING ch_o_wb_object_set = re_wb_objects_set ).
    me-&gt;load_interfaces( CHANGING ch_o_wb_object_set = re_wb_objects_set ).


  ENDMETHOD.                    &quot;ZIF_WB_MASS_LOADER~MASS_LOAD</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="CONSTRUCTOR" SCONAME="IM_O_WB_OO_SEARCHER" VERSION="1" LANGU="E" DESCRIPT="IM_O_WB_OO_SEARCHER" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZCL_WB_SEARCHER_OO"/>
   <source>METHOD constructor.

    me-&gt;o_wb_oo_searcher = im_o_wb_oo_searcher.

  ENDMETHOD.                    &quot;CONSTRUCTOR</source>
  </method>
  <method CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_CLASSES" VERSION="1" LANGU="E" DESCRIPT="LOAD_CLASSES" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_CLASSES" SCONAME="CH_O_WB_OBJECT_SET" VERSION="1" LANGU="E" DESCRIPT="CH_O_WB_OBJECT_SET" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_WB_SET_ITAB"/>
   <source>METHOD load_classes.


    DATA lwa_class TYPE zcl_wb_searcher=&gt;ty_class.
    DATA lo_new_class TYPE REF TO zcl_wb_class_global.
    DATA lwa_seoclskey TYPE seoclskey.
    LOOP AT me-&gt;o_wb_oo_searcher-&gt;t_classes INTO lwa_class. &quot; Transform itab into parameter because this method can be reused when loading a package

      lwa_seoclskey-clsname = lwa_class-clsname.

      CREATE OBJECT lo_new_class
        EXPORTING
          im_clskey                    = lwa_seoclskey
*         im_version                   = SEOC_VERSION_INACTIVE
*         im_state                     = &apos;1&apos;
*         im_with_descriptions         = SEOX_TRUE
*         im_resolve_eventhandler_info = SEOX_FALSE
*         im_with_master_language      = SEOX_FALSE
*         im_with_enhancements         = SEOX_FALSE
*         im_read_active_enha          = SEOX_FALSE
*         im_enha_action               = SEOX_FALSE
*         im_ignore_switches           = &apos;X&apos;
        .

      TRY .
          lo_new_class-&gt;zif_wb_object~load( ).
        CATCH zcx_wb_objects.    &quot; WB Objects generic exception
          RAISE EXCEPTION TYPE zcx_wb_objects.
      ENDTRY.

      APPEND lo_new_class TO ch_o_wb_object_set-&gt;t_wb_objects.
    ENDLOOP.


  ENDMETHOD.                    &quot;load_classes</source>
  </method>
  <method CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="LOAD_INTERFACES" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_INTERFACES" SCONAME="CH_O_WB_OBJECT_SET" VERSION="1" LANGU="E" DESCRIPT="CH_O_WB_OBJECT_SET" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_WB_SET_ITAB"/>
   <source>METHOD load_interfaces.


    DATA lwa_interface TYPE zcl_wb_searcher=&gt;ty_interface.
    DATA lo_new_interface TYPE REF TO zcl_wb_interface_global.
    DATA lwa_seoclskey TYPE seoclskey.

    LOOP AT me-&gt;o_wb_oo_searcher-&gt;t_interfaces INTO lwa_interface. &quot; Transform itab into parameter because this method can be reused when loading a package

      lwa_seoclskey-clsname = lwa_interface-intname.
      CREATE OBJECT lo_new_interface
        EXPORTING
          im_intkey               = lwa_seoclskey
*         im_version              = SEOC_VERSION_INACTIVE
*         im_state                = &apos;1&apos;
*         im_with_master_language = SEOX_FALSE
*         im_with_enhancements    = SEOX_FALSE
*         im_read_active_enha     = SEOX_FALSE
*         im_enha_action          = SEOX_FALSE
*         im_ignore_switches      = &apos;X&apos;
        .

      TRY .
          lo_new_interface-&gt;zif_wb_object~load( ).
        CATCH zcx_wb_objects.    &quot; WB Objects generic exception

      ENDTRY.

      APPEND lo_new_interface TO ch_o_wb_object_set-&gt;t_wb_objects.
    ENDLOOP.


  ENDMETHOD.                    &quot;load_interfaces</source>
  </method>
  <method CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_PACKAGE_CONTENTS" VERSION="1" LANGU="E" DESCRIPT="LOAD_PACKAGE_CONTENTS" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_PACKAGE_CONTENTS" SCONAME="CH_O_WB_OBJECT_SET" VERSION="1" LANGU="E" DESCRIPT="CH_O_WB_OBJECT_SET" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_WB_SET_ITAB"/>
   <source>METHOD load_package_contents.

* Classes
*    DATA lwa_package TYPE zcl_wb_searcher=&gt;ty_package.

    TYPES: BEGIN OF lty_tadir,
      obj_name TYPE tadir-obj_name,
      END OF lty_tadir,
      ltt_tadir TYPE STANDARD TABLE OF lty_tadir WITH KEY obj_name.
    DATA lt_tadir TYPE ltt_tadir.

    IF me-&gt;o_wb_oo_searcher-&gt;t_packages IS NOT INITIAL.

      SELECT
        obj_name
      FROM
        tadir
      INTO TABLE
        lt_tadir
      FOR ALL ENTRIES IN
        me-&gt;o_wb_oo_searcher-&gt;t_packages
      WHERE
        pgmid = &apos;R3TR&apos; AND
        object IN (&apos;CLAS&apos;,&apos;INTF&apos;) AND
        devclass = me-&gt;o_wb_oo_searcher-&gt;t_packages-devclass.

    ENDIF.

    IF sy-subrc IS INITIAL .

      DATA lwa_tadir TYPE lty_tadir.
      LOOP AT lt_tadir INTO lwa_tadir.



      ENDLOOP.
    ENDIF.

*    LOOP AT me-&gt;o_wb_oo_searcher-&gt;t_packages INTO lwa_package.
*
*    ENDLOOP.

  ENDMETHOD.                    &quot;LOAD_PACKAGE_CONTENTS</source>
  </method>
  <method CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="LOAD_PROGRAMS" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_MASS_LOADER_OO_SEARCHER" CMPNAME="LOAD_PROGRAMS" SCONAME="CH_O_WB_OBJECT_SET" VERSION="1" LANGU="E" DESCRIPT="CH_O_WB_OBJECT_SET" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_WB_SET_ITAB"/>
   <source>METHOD load_programs.


*    DATA lwa_program TYPE zcl_wb_searcher=&gt;ty_program.
*
*    LOOP AT me-&gt;o_wb_oo_searcher-&gt;t_programs INTO lwa_program.
*
*    ENDLOOP.


  ENDMETHOD.                    &quot;LOAD_PROGRAMS</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SEARCHER" VERSION="1" LANGU="E" DESCRIPT="ZCL_WB_SEARCHER" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TY_PACKAGE" VERSION="1" LANGU="E" DESCRIPT="TY_PACKAGE" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="10 " SRCCOLUMN1="4 " SRCROW2="13 " SRCCOLUMN2="22 " TYPESRC_LENG="126 " TYPESRC="BEGIN OF ty_package,
          devclass TYPE tdevc-devclass,
          text    TYPE tdevct-ctext,
      END OF ty_package
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TT_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="TT_PACKAGES" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="15 " SRCCOLUMN1="4 " SRCROW2="15 " SRCCOLUMN2="100 " TYPESRC_LENG="99 " TYPESRC="tt_packages TYPE STANDARD TABLE OF ty_package WITH UNIQUE SORTED KEY devclass COMPONENTS devclass
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TY_PROGRAM" VERSION="1" LANGU="E" DESCRIPT="TY_PROGRAM" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4" SRCROW1="17 " SRCCOLUMN1="4 " SRCROW2="20 " SRCCOLUMN2="22 " TYPESRC_LENG="130 " TYPESRC="BEGIN OF ty_program,
          progname  TYPE reposrc-progname,
          text      TYPE trdirt-text,
      END OF ty_program
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TT_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="TT_PROGRAMS" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="4" SRCROW1="22 " SRCCOLUMN1="4 " SRCROW2="22 " SRCCOLUMN2="100 " TYPESRC_LENG="99 " TYPESRC="tt_programs TYPE STANDARD TABLE OF ty_program WITH UNIQUE SORTED KEY progname COMPONENTS progname
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TY_CLASS" VERSION="1" LANGU="E" DESCRIPT="TY_CLASS" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4" SRCROW1="24 " SRCCOLUMN1="4 " SRCROW2="27 " SRCCOLUMN2="20 " TYPESRC_LENG="122 " TYPESRC="BEGIN OF ty_class,
      clsname TYPE seoclass-clsname,
      text    TYPE seoclasstx-descript,
      END OF ty_class
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TT_CLASSES" VERSION="1" LANGU="E" DESCRIPT="TT_CLASSES" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4" SRCROW1="29 " SRCCOLUMN1="4 " SRCROW2="29 " SRCCOLUMN2="95 " TYPESRC_LENG="94 " TYPESRC="tt_classes TYPE STANDARD TABLE OF ty_class WITH UNIQUE SORTED KEY clsname COMPONENTS clsname
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TY_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="TY_INTERFACE" EXPOSURE="2" STATE="1" EDITORDER="7 " TYPTYPE="4" SRCROW1="31 " SRCCOLUMN1="4 " SRCROW2="34 " SRCCOLUMN2="24 " TYPESRC_LENG="130 " TYPESRC="BEGIN OF ty_interface,
      intname TYPE seoclass-clsname,
      text    TYPE seoclasstx-descript,
      END OF ty_interface
"/>
  <types CLSNAME="ZCL_WB_SEARCHER" CMPNAME="TT_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="TT_INTERFACES" EXPOSURE="2" STATE="1" EDITORDER="8 " TYPTYPE="4" SRCROW1="36 " SRCCOLUMN1="4 " SRCROW2="36 " SRCCOLUMN2="102 " TYPESRC_LENG="101 " TYPESRC="tt_interfaces TYPE STANDARD TABLE OF ty_interface WITH UNIQUE SORTED KEY intname COMPONENTS intname
"/>
  <implementing CLSNAME="ZCL_WB_SEARCHER" REFCLSNAME="ZIF_WB_SEARCHER" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_SEARCHER" CMPNAME="O_WB_SEARCH_CRITERIA" VERSION="1" LANGU="E" DESCRIPT="O_WB_SEARCH_CRITERIA" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZIF_WB_SEARCH_CRITERIA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER" CMPNAME="T_CLASSES" VERSION="1" LANGU="E" DESCRIPT="T_CLASSES" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER" CMPNAME="T_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="T_INTERFACES" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_INTERFACES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER" CMPNAME="T_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="T_PACKAGES" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_PACKAGES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER" CMPNAME="T_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="T_PROGRAMS" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TT_PROGRAMS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCHER" CPDNAME="ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS">
   <source>method ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS.

    me-&gt;o_wb_search_criteria = im_wb_search_criteria.

    me-&gt;search_packages( CHANGING ch_t_packages = me-&gt;t_packages ).
    me-&gt;search_programs( CHANGING ch_t_programs = me-&gt;t_programs ).
    me-&gt;search_classes( CHANGING ch_t_classes = me-&gt;t_classes ).
    me-&gt;search_interfaces( CHANGING ch_t_interfaces = me-&gt;t_interfaces ).
    me-&gt;search_function_groups( ).
    me-&gt;search_function_modules( ).
    me-&gt;search_type_pools( ).
    me-&gt;search_tables( ).
    me-&gt;search_views( ).
    me-&gt;search_domains( ).
    me-&gt;search_data_elements( ).
    me-&gt;search_structures( ).
    me-&gt;search_table_types( ).
    me-&gt;search_lock_objects( ).
    me-&gt;search_search_helps( ).


endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CONSTRUCTOR.



endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_CLASSES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_CLASSES" EXPOSURE="1" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_CLASSES" SCONAME="CH_T_CLASSES" VERSION="1" LANGU="E" DESCRIPT="CH_T_CLASSES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_CLASSES"/>
   <source>method SEARCH_CLASSES.


    IF me-&gt;o_wb_search_criteria-&gt;r_classes IS NOT INITIAL.

      SELECT
          class~clsname
          ctext~descript
        FROM
          seoclass AS class JOIN
          seoclasstx AS ctext
        ON
          class~clsname = ctext~clsname
        INTO TABLE
          ch_t_classes
        WHERE
          class~clsname IN me-&gt;o_wb_search_criteria-&gt;r_classes AND
          class~clstype = &apos;0&apos; AND &quot; Classes
          langu   = sy-langu.

    ENDIF.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_DATA_ELEMENTS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_DATA_ELEMENTS" EXPOSURE="1" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_DATA_ELEMENTS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_DOMAINS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_DOMAINS" EXPOSURE="1" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_DOMAINS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_FUNCTION_GROUPS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_FUNCTION_GROUPS" EXPOSURE="1" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_FUNCTION_GROUPS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_FUNCTION_MODULES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_FUNCTION_MODULES" EXPOSURE="1" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_FUNCTION_MODULES.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_INTERFACES" EXPOSURE="1" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_INTERFACES" SCONAME="CH_T_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="CH_T_INTERFACES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_INTERFACES"/>
   <source>method SEARCH_INTERFACES.


    IF me-&gt;o_wb_search_criteria-&gt;r_interfaces IS NOT INITIAL.

      SELECT
          inter~clsname
          ctext~descript
        FROM
          seoclass AS inter JOIN
          seoclasstx AS ctext
        ON
          inter~clsname = ctext~clsname
        INTO TABLE
          ch_t_interfaces
        WHERE
          inter~clsname IN me-&gt;o_wb_search_criteria-&gt;r_interfaces AND
          inter~clstype = &apos;1&apos; AND &quot; Interfaces
          langu   = sy-langu.

    ENDIF.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_LOCK_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_LOCK_OBJECTS" EXPOSURE="1" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_LOCK_OBJECTS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_PACKAGES" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_PACKAGES" SCONAME="CH_T_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="CH_T_PACKAGES" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_PACKAGES"/>
   <source>method SEARCH_PACKAGES.


    IF me-&gt;o_wb_search_criteria-&gt;r_packages IS NOT INITIAL.

      SELECT
          devclass
          ctext
        FROM
          tdevct
        INTO TABLE
          ch_t_packages
        WHERE
          devclass IN me-&gt;o_wb_search_criteria-&gt;r_packages AND
          spras = sy-langu.

    ENDIF.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_PROGRAMS" EXPOSURE="1" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_PROGRAMS" SCONAME="CH_T_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="CH_T_PROGRAMS" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_PROGRAMS"/>
   <source>method SEARCH_PROGRAMS.


    IF me-&gt;o_wb_search_criteria-&gt;r_reports IS NOT INITIAL.

      SELECT
        progname
        text
        FROM
          reposrc AS repo JOIN
          trdirt  AS rtext
        ON
          repo~progname = rtext~name
        INTO TABLE
          ch_t_programs
        WHERE
          progname IN me-&gt;o_wb_search_criteria-&gt;r_reports AND
          r3state = &apos;A&apos; AND &quot; Active programs/includes
          sprsl = sy-langu.

    ENDIF.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_SEARCH_HELPS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_SEARCH_HELPS" EXPOSURE="1" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_SEARCH_HELPS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_STRUCTURES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_STRUCTURES" EXPOSURE="1" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_STRUCTURES.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_TABLES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_TABLES" EXPOSURE="1" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_TABLES.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_TABLE_TYPES" VERSION="1" LANGU="E" DESCRIPT="SEARCH_TABLE_TYPES" EXPOSURE="1" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_TABLE_TYPES.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_TYPE_POOLS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_TYPE_POOLS" EXPOSURE="1" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_TYPE_POOLS.


endmethod.</source>
  </method>
  <method CLSNAME="ZCL_WB_SEARCHER" CMPNAME="SEARCH_VIEWS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_VIEWS" EXPOSURE="1" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method SEARCH_VIEWS.


endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SEARCHER_OO" VERSION="1" LANGU="E" DESCRIPT="ZCL_WB_SEARCHER_OO" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZCL_WB_SEARCHER">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <attribute CLSNAME="ZCL_WB_SEARCHER_OO" CMPNAME="T_CLASSES" VERSION="1" LANGU="E" DESCRIPT="T_CLASSES" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_WB_SEARCHER=&gt;TT_CLASSES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER_OO" CMPNAME="T_INTERFACES" VERSION="1" LANGU="E" DESCRIPT="T_INTERFACES" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_WB_SEARCHER=&gt;TT_INTERFACES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER_OO" CMPNAME="T_PACKAGES" VERSION="1" LANGU="E" DESCRIPT="T_PACKAGES" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_WB_SEARCHER=&gt;TT_PACKAGES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_WB_SEARCHER_OO" CMPNAME="T_PROGRAMS" VERSION="1" LANGU="E" DESCRIPT="T_PROGRAMS" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTRDONLY="X" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZCL_WB_SEARCHER=&gt;TT_PROGRAMS" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <inheritance CLSNAME="ZCL_WB_SEARCHER_OO" REFCLSNAME="ZCL_WB_SEARCHER" VERSION="1" STATE="1">
   <redefinition CLSNAME="ZCL_WB_SEARCHER_OO" REFCLSNAME="ZCL_WB_SEARCHER" VERSION="1" MTDNAME="ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS" EXPOSURE="0"/>
  </inheritance>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCHER_OO" CPDNAME="ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS">
   <source>method ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS.

    me-&gt;o_wb_search_criteria = im_wb_search_criteria.

    me-&gt;search_packages( CHANGING ch_t_packages = me-&gt;t_packages ).
    me-&gt;search_programs( CHANGING ch_t_programs = me-&gt;t_programs ).
    me-&gt;search_classes( CHANGING ch_t_classes = me-&gt;t_classes ).
    me-&gt;search_interfaces( CHANGING ch_t_interfaces = me-&gt;t_interfaces ).


endmethod.</source>
  </interfaceMethod>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SEARCHER_STUB" VERSION="1" LANGU="E" DESCRIPT="ZCL_WB_SEARCHER_STUB" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
  <implementing CLSNAME="ZCL_WB_SEARCHER_STUB" REFCLSNAME="ZIF_WB_SEARCHER" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="0 "/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <interfaceMethod CLSNAME="ZCL_WB_SEARCHER_STUB" CPDNAME="ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS">
   <source>method ZIF_WB_SEARCHER~SEARCH_WB_OBJECTS.


endmethod.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_WB_SEARCHER_STUB" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>method CONSTRUCTOR.



endmethod.</source>
  </method>
 </CLAS>
 <CLAS CLSNAME="ZCL_WB_SEARCHER_TEST" VERSION="1" LANGU="E" DESCRIPT="ZCL_WB_SEARCHER_TEST" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="12 " RISK_LEVEL="11 ">
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
 </CLAS>
 <INTF CLSNAME="ZIF_WB_MASS_LOADER" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <method CLSNAME="ZIF_WB_MASS_LOADER" CMPNAME="MASS_LOAD" VERSION="1" LANGU="E" DESCRIPT="MASS_LOAD" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_WB_MASS_LOADER" CMPNAME="MASS_LOAD" SCONAME="RE_WB_OBJECTS_SET" VERSION="1" LANGU="E" DESCRIPT="RE_WB_OBJECTS_SET" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZIF_WB_SET_ITAB"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_WB_SEARCHER" VERSION="1" LANGU="E" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X">
  <method CLSNAME="ZIF_WB_SEARCHER" CMPNAME="SEARCH_WB_OBJECTS" VERSION="1" LANGU="E" DESCRIPT="SEARCH_WB_OBJECTS" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZIF_WB_SEARCHER" CMPNAME="SEARCH_WB_OBJECTS" SCONAME="IM_WB_SEARCH_CRITERIA" VERSION="1" LANGU="E" DESCRIPT="IM_WB_SEARCH_CRITERIA" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="ZIF_WB_SEARCH_CRITERIA"/>
  </method>
 </INTF>
 <INTF CLSNAME="ZIF_WB_FAKE_INTERFACE" VERSION="1" LANGU="E" DESCRIPT="Fake Interface" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" UNICODE="X"/>
 <PROG NAME="ZI_WB_FAKE_CLASS_LOCAL" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_WB_FAKE_CLASS_LOCAL" LENGTH="30 "/>
   </language>
  </textPool>
  <source>*----------------------------------------------------------------------*
*       CLASS lcl_a DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_a DEFINITION.

ENDCLASS.                    &quot;lcl_a DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_a IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_a IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_a IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_b DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_b DEFINITION.

ENDCLASS.                    &quot;lcl_b DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_b IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_b IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_b IMPLEMENTATION</source>
 </PROG>
 <PROG NAME="ZI_WB_FAKE_NO_CLASSES" VARCL="X" SUBC="I" APPL="S" RMAND="001" RLOAD="E" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Include ZI_WB_FAKE_NO_CLASSES" LENGTH="29 "/>
   </language>
  </textPool>
  <source>* This include can&apos;t contain a local class

INTERFACE ZI_WB_FAKE_NO_CLASSES.

ENDINTERFACE.</source>
 </PROG>
</nugget>
